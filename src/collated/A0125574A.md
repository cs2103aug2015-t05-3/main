# A0125574A
###### logic\command\CmdDelete.java
``` java

/**
 * Command to delete a specified {@code Task} 
 */

package logic.command;

import java.util.logging.Level;

import constants.CmdParameters;
import logger.LogHandler;
import taskCollections.Task;
import taskCollections.Task.FLAG_TYPE;

public class CmdDelete extends Command {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_TASKIDNOTFOUND = "Specified taskID \"%1$s\" not found";
	private static final String MSG_TASKDELETED = "Deleted : \"%1$s\"";

	// Help Info
	private static final String HELP_INFO_DELETE = "<task_ID>";

	// Log Message
	private static final String LOG_NUMBERFORMATEXCEPTION = "\"%1$s\" is not an integer";
	private static final String LOG_DELETE_SUCCESS = "Delete Task Success";
	private static final String LOG_DELETE_FAIL = "Delete Task Fail";

	// Variable constant
	private static final int INVALID_TASKID = -1;

	/*
	 * Variables for internal use
	 */
	private Task _task;
	private int _taskID;

	public CmdDelete() {

	}

	/**
	 * Deletes a specified {@code Task}
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction execute() {

		// Try undo first
		_task = getTask();
		if (isUndo()) {
			return deleteTask(_task);
		}

		if (!hasTaskToDelete()) {
			return new CommandAction(String.format(MSG_TASKIDNOTFOUND, _taskID), false, null);
		}

		return deleteTask(_task);
	}

	/**
	 * Undo the action of a previously deleted {@code Task}
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction undo() {
		Command add = new CmdAdd(_task.getName());
		add.setTask(_task);
		return add.execute();
	}

	@Override
	public String[] getRequiredFields() {
		return new String[] { CmdParameters.PARAM_NAME_TASK_ID };
	}

	@Override
	public String[] getOptionalFields() {
		return new String[] {};
	}

	/**
	 * Returns a syntax message for delete command
	 * 
	 * @return a syntax message for delete command
	 */
	@Override
	public String getHelpInfo() {
		return HELP_INFO_DELETE;
	}

	/**
	 * Determine delete action is called by undo command
	 * 
	 * @return true if delete action is called by undo. false if delete action
	 *         is not called by undo.
	 */
	private boolean isUndo() {
		if (_task == null) {
			return false;
		} else {
			return true;
		}
	}

	/**
	 * Check if a {@code Task} exist to be deleted.
	 * 
	 * @return true if {@code Task} is not null. false if {@code Task} is null.
	 */
	private boolean hasTaskToDelete() {
		String paramTaskID = getParameterValue(CmdParameters.PARAM_NAME_TASK_ID);
		_task = proccessTaskID(paramTaskID);
		if (_task == null || _task.equals("")) {
			return false;
		} else {
			return true;
		}

	}

	/**
	 * Process the given task ID and returns a Task of the specified ID.
	 * 
	 * @param paramTaskID
	 *            a String parameter of task ID.
	 * 
	 * @return a {@code Task} of the specified ID.
	 */
	private Task proccessTaskID(String paramTaskID) {
		assert paramTaskID != null && !paramTaskID.equals("");
		try {
			_taskID = Integer.parseInt(paramTaskID);
		} catch (NumberFormatException e) {
			LogHandler.getLog().log(Level.WARNING, String.format(LOG_NUMBERFORMATEXCEPTION, paramTaskID));
			_taskID = INVALID_TASKID;
		}
		return _taskTree.getTask(_taskID);
	}

	/**
	 * Delete a specified {@code Task}
	 *
	 * @param task
	 *            {@code Task} to be deleted
	 *
	 * @return a CommandAction of deleting a {@code Task} successfully
	 * 
	 */
	private CommandAction deleteTask(Task task) {
		assert task != null;

		try {
			_taskTree.remove(task);
			LogHandler.getLog().log(Level.INFO, LOG_DELETE_SUCCESS);
		} catch (Exception e) {
			LogHandler.getLog().log(Level.WARNING, LOG_DELETE_FAIL, e);
		}

		return new CommandAction(String.format(MSG_TASKDELETED, _task.getName()), true,
				_taskTree.searchFlag(FLAG_TYPE.NULL));
	}

}
```
###### logic\command\CmdExit.java
``` java

/**
 * Command to exit TaskBuddy 
 */

package logic.command;

public class CmdExit extends Command {

	// Help Info
	private static final String HELP_INFO_EXIT = "Just exit...";

	/**
	 * Exits TaskBuddy
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction execute() {
		System.exit(0);
		return new CommandAction("", false, null);
	}

	@Override
	public CommandAction undo() {
		// do nothing (Exit should not have undo)
		return null;
	}

	@Override
	public String[] getRequiredFields() {
		return new String[] {};
	}

	@Override
	public String[] getOptionalFields() {
		return new String[] {};
	}

	/**
	 * Returns a syntax message for exit command
	 * 
	 * @return a syntax message for exit command
	 */
	@Override
	public String getHelpInfo() {
		return HELP_INFO_EXIT;
	}

}
```
###### logic\command\CmdHelp.java
``` java

/**
 * Command to display a help window containing syntax of all command 
 */

package logic.command;

import ui.UIHelper;

public class CmdHelp extends Command {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_HELP = "Help shown";

	// Help constants
	private static final String HELP_INFO_HELP = "Just help...";

	public CmdHelp() {

	}

	/**
	 * Display help message with syntax of other commands
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction execute() {
		UIHelper.showHelpPanel();
		return new CommandAction(MSG_HELP, false, null);
	}

	@Override
	public CommandAction undo() {
		// do nothing (Help should not have undo)
		return null;
	}

	@Override
	public String[] getRequiredFields() {
		return new String[] {};
	}

	@Override
	public String[] getOptionalFields() {
		return new String[] {};
	}

	/**
	 * Returns a syntax message for help command
	 * 
	 * @return a syntax message for help command
	 */
	@Override
	public String getHelpInfo() {
		return HELP_INFO_HELP;
	}

}
```
###### logic\command\CmdList.java
``` java

/**
 * Command to display a list of {@code Task} 
 */

package logic.command;

import java.util.List;

import constants.CmdParameters;
import parser.ParserConstants;

import taskCollections.Task;
import taskCollections.Task.PRIORITY_TYPE;
import taskCollections.Task.FLAG_TYPE;

public class CmdList extends Command {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_EMPTY_TASKTREE = "No tasks to display";
	private static final String MSG_TOTAL_TASK = "Total tasks in list: [%1$s]";

	// Help Info
	private static final String HELP_INFO_LIST = "[%1$s or %2$s or %3$s <high/normal/low/h/n/l>]";

	// Variable constants
	private static final int EMPTY_LIST = 0;

	public CmdList() {

	}

	/**
	 * Display a list of {@code Task}
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction execute() {

		if (isEmptyTaskList()) {
			return new CommandAction(MSG_EMPTY_TASKTREE, false, _taskTree.getList());
		}

		String optionalParameter = getParameterValue(CmdParameters.PARAM_NAME_LIST_FLAG);
		List<Task> taskList = proccessParameter(optionalParameter);
		return new CommandAction(String.format(MSG_TOTAL_TASK, taskList.size()), false, taskList);

	}

	@Override
	public CommandAction undo() {
		// do nothing (List should not have undo)
		return null;
	}

	@Override
	public String[] getRequiredFields() {
		return new String[] {};
	}

	@Override
	public String[] getOptionalFields() {
		return new String[] { CmdParameters.PARAM_NAME_LIST_FLAG, CmdParameters.PARAM_NAME_TASK_PRIORITY };
	}

	/**
	 * Returns a syntax message for list command
	 * 
	 * @return a syntax message for list command
	 */
	@Override
	public String getHelpInfo() {
		return String.format(HELP_INFO_LIST, ParserConstants.TASK_FILTER_ALL, ParserConstants.TASK_FILTER_DONE,
				ParserConstants.TASK_SPECIFIER_PRIORITY);
	}

	/**
	 * Checks if list is empty
	 * 
	 * @return true if list is empty. false if list is not empty
	 */
	private boolean isEmptyTaskList() {
		assert _taskTree != null;

		if (_taskTree.size() == EMPTY_LIST) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Returns a list of undone {@code Task}
	 * 
	 * @return a list of undone {@code Task}
	 */
	private List<Task> getUndoneTask() {
		assert _taskTree != null;
		return _taskTree.searchFlag(FLAG_TYPE.NULL);
	}

	/**
	 * Returns a list of completed {@code Task}
	 * 
	 * @return a list of completed {@code Task}
	 */
	private List<Task> getDoneTask() {
		assert _taskTree != null;
		return _taskTree.searchFlag(FLAG_TYPE.DONE);
	}

	/**
	 * Returns a list of {@code Task} with specified priority
	 * 
	 * @param priority
	 *            priority type to be listed
	 * 
	 * @return a list of {@code Task} with specified priority
	 */
	private List<Task> getPriorityTask(String priority) {

		if (priority == null) {
			priority = "";
		}
		PRIORITY_TYPE priorityType;
		switch (priority) {
			case CmdParameters.PARAM_VALUE_TASK_PRIORITY_HIGH:
				priorityType = PRIORITY_TYPE.HIGH;
				break;
			case CmdParameters.PARAM_VALUE_TASK_PRIORITY_NORM:
				priorityType = PRIORITY_TYPE.NORMAL;
				break;
			case CmdParameters.PARAM_VALUE_TASK_PRIORITY_LOW:
				priorityType = PRIORITY_TYPE.LOW;
				break;
			default:
				priorityType = PRIORITY_TYPE.NORMAL;
				break;
		}

		assert _taskTree != null;
		return _taskTree.searchPriority(priorityType);

	}

	/**
	 * Returns a list of all existing {@code Task}
	 * 
	 * @return a list of all existing {@code Task}
	 */
	private List<Task> getAllTask() {
		assert _taskTree != null;
		return _taskTree.getList();
	}

	/**
	 * Process given parameter and return a list of {@code Task} based on the
	 * given parameter
	 * 
	 * @param parameter
	 *            parameter to be processed
	 * 
	 * @return a list of {@code Task} based on given parameter
	 */
	private List<Task> proccessParameter(String parameter) {

		if (parameter == null) {
			parameter = "";
		}

		List<Task> taskList;

		switch (parameter) {
			case CmdParameters.PARAM_VALUE_LIST_ALL:
				taskList = getAllTask();
				break;
			case CmdParameters.PARAM_VALUE_LIST_DONE:
				taskList = getDoneTask();
				break;
			case CmdParameters.PARAM_VALUE_LIST_PRIORITY:
				String paramPriority = getParameterValue(CmdParameters.PARAM_NAME_TASK_PRIORITY);
				taskList = getPriorityTask(paramPriority);
				break;
			default:
				taskList = getUndoneTask();
				break;
		}

		return taskList;
	}

}
```
###### logic\command\CmdMark.java
``` java

/**
 * Command to mark/unmark a specified task 
 */

package logic.command;

import java.util.logging.Level;

import constants.CmdParameters;
import logger.LogHandler;
import parser.ParserConstants;
import taskCollections.Task;
import taskCollections.Task.FLAG_TYPE;

public class CmdMark extends Command {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_TASKIDNOTFOUND = "Specified taskID \"%1$s\" not found";
	private static final String MSG_TASKMARKED = "Marked: \"%1$s\"";
	private static final String MSG_TASKUNMARKED = "Unmarked: \"%1$s\"";
	private static final String MSG_TASKALREADYMARKED = "Task: \"%1$s\" already marked";
	private static final String MSG_TASKALREADYUNMARKED = "Task: \"%1$s\" already unmarked";

	// Help Info
	private static final String HELP_INFO_MARK = "<task_ID> [%1$s]";

	// Log Message
	private static final String LOG_NUMBERFORMATEXCEPTION = "\"%1$s\" is not an integer";

	// Variable Constant
	private static final int INVALID_TASKID = -1;

	/*
	 * Variables for internal use
	 */
	private Task _task;
	private int _taskID;
	private boolean _isUnmarkParam;

	public CmdMark() {

	}

	/**
	 * Mark/Unmark a specified {@code Task}
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction execute() {

		if (!hasTaskToMark()) {
			return new CommandAction(String.format(MSG_TASKIDNOTFOUND, _taskID), false, null);
		}

		proccessOptionalParam();
		if (_isUnmarkParam) {
			return unmarkTask(_task);
		} else {
			return markTask(_task);
		}

	}

	/**
	 * Undo the action to a previously marked/unmarked {@code Task}
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction undo() {

		// reverse order in undo
		if (_isUnmarkParam) {
			return markTask(_task);
		} else {
			return unmarkTask(_task);
		}

	}

	@Override
	public String[] getRequiredFields() {
		return new String[] { CmdParameters.PARAM_NAME_TASK_ID };
	}

	@Override
	public String[] getOptionalFields() {
		return new String[] { CmdParameters.PARAM_NAME_MARK_FLAG };
	}

	/**
	 * Returns a syntax message for mark command
	 * 
	 * @return a syntax message for mark command
	 */
	@Override
	public String getHelpInfo() {
		return String.format(HELP_INFO_MARK, ParserConstants.TASK_MARK_UNMARK);
	}

	/**
	 * Check if a {@code Task} exist to be marked/unmarked.
	 * 
	 * @return true if {@code Task} is not null. false if {@code Task} is null.
	 */
	private boolean hasTaskToMark() {
		String paramTaskID = getParameterValue(CmdParameters.PARAM_NAME_TASK_ID);
		_task = proccessTaskID(paramTaskID);
		if (_task == null || _task.equals("")) {
			return false;
		} else {
			return true;
		}
	}

	/**
	 * Process the given task ID and returns a Task of the specified ID.
	 * 
	 * @param paramTaskID
	 *            a String parameter of task ID.
	 * 
	 * @return a {@code Task} of the specified ID.
	 */
	private Task proccessTaskID(String paramTaskID) {
		assert paramTaskID != null && !paramTaskID.equals("");

		try {
			_taskID = Integer.parseInt(paramTaskID);
		} catch (NumberFormatException e) {
			LogHandler.getLog().log(Level.WARNING, String.format(LOG_NUMBERFORMATEXCEPTION, paramTaskID));
			_taskID = INVALID_TASKID;
		}

		return _taskTree.getTask(_taskID);
	}

	/**
	 * Process optional parameter and determine if {@code Task} is to be marked
	 * or unmarked
	 */
	private void proccessOptionalParam() {
		String optionalParam = getParameterValue(CmdParameters.PARAM_NAME_MARK_FLAG);
		if (optionalParam != CmdParameters.PARAM_VALUE_MARK_UNMARK) {
			_isUnmarkParam = false;
		} else {
			_isUnmarkParam = true;
		}
	}

	/**
	 * Check if a {@code Task} has been marked
	 * 
	 * @param task
	 *            a {@code Task}
	 * 
	 * @return true if task is marked. false if task is unmarked.
	 */
	private boolean isMarked(Task task) {
		assert task != null;

		if (task.getFlag() == FLAG_TYPE.NULL) {
			return false;
		} else {
			return true;
		}
	}

	/**
	 * Mark a specified {@code Task}
	 * 
	 * @param task
	 *            a {@code Task} to be marked
	 * 
	 * @return a CommandAction of marking a {@code Task}
	 */
	private CommandAction markTask(Task task) {
		assert task != null;

		if (isMarked(task)) {
			return new CommandAction(String.format(MSG_TASKALREADYMARKED, _task.getName()), false,
					_taskTree.searchFlag(FLAG_TYPE.NULL));
		} else {
			_taskTree.updateFlag(task, FLAG_TYPE.DONE);
			return new CommandAction(String.format(MSG_TASKMARKED, task.getName()), true,
					_taskTree.searchFlag(FLAG_TYPE.NULL));
		}
	}

	/**
	 * Unmark a specified {@code Task}
	 * 
	 * @param task
	 *            a {@code Task} to be marked
	 * 
	 * @return a CommandAction of unmarking a {@code Task}
	 */
	private CommandAction unmarkTask(Task task) {
		assert task != null;

		if (isMarked(task)) {
			_taskTree.updateFlag(task, FLAG_TYPE.NULL);
			return new CommandAction(String.format(MSG_TASKUNMARKED, task.getName()), true,
					_taskTree.searchFlag(FLAG_TYPE.NULL));
		} else {

			return new CommandAction(String.format(MSG_TASKALREADYUNMARKED, _task.getName()), false,
					_taskTree.searchFlag(FLAG_TYPE.NULL));
		}
	}

}
```
###### logic\command\CmdSearch.java
``` java

/**
 * Command to search for all {@code Task} with task name containing a specified keyword
 */

package logic.command;

import java.util.List;

import constants.CmdParameters;

import taskCollections.Task;

public class CmdSearch extends Command {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_KEYWORD_UNSPECIFIED = "Please specify a keyword to search";
	private static final String MSG_KEYWORD_NOTFOUND = "Specified keyword \"%1$s\" not found";
	private static final String MSG_TASKFOUND = "Task \"%1$s\" found";
	private static final String MSG_ISNTANCEFOUND = "[%1$s] instances of \"%2$s\" found";

	// Help Info
	private static final String HELP_INFO_SEARCH = "<keyword>";

	/*
	 * Variables for internal use
	 */
	public String _keyword;

	public CmdSearch() {

	}

	/**
	 * Search all {@code Task} with task name containing a specified keyword
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction execute() {
		if (!hasKeywordToSearch()) {
			return new CommandAction(MSG_KEYWORD_UNSPECIFIED, false, null);
		}

		return searchKeyword();
	}

	@Override
	public CommandAction undo() {
		// do nothing (Search should not have undo)
		return null;
	}

	@Override
	public String[] getRequiredFields() {
		return new String[] { CmdParameters.PARAM_NAME_CMD_SEARCH };
	}

	@Override
	public String[] getOptionalFields() {
		return new String[] {};
	}

	/**
	 * Returns a syntax message for search command
	 * 
	 * @return a syntax message for search command
	 */
	@Override
	public String getHelpInfo() {
		return HELP_INFO_SEARCH;
	}

	/**
	 * Checks if there is a keyword to be searched.
	 * 
	 * @return true if there is a keyword to be searched. false if there is no
	 *         keyword to be searched
	 */
	private boolean hasKeywordToSearch() {
		_keyword = getParameterValue(CmdParameters.PARAM_NAME_CMD_SEARCH);
		if (_keyword == null || _keyword.equals("")) {
			return false;
		} else {
			return true;
		}

	}

	/**
	 * Checks if there is a keyword to be searched.
	 * 
	 * @return a CommandAction with results of searching a keyword
	 */
	private CommandAction searchKeyword() {
		List<Task> taskList = getTaskList(_keyword);
		String outputMsg = getOutputMsg(taskList);
		return new CommandAction(outputMsg, false, taskList);
	}

	/**
	 * Returns a List of {@code Task} with task name containing the keyword
	 * 
	 * @param keyword
	 *            keyword to be searched
	 * 
	 * @return a List of {@code Task} with task name containing the keyword
	 */
	private List<Task> getTaskList(String keyword) {
		assert keyword != null && !keyword.equals("");
		return _taskTree.searchName(keyword);
	}

	/**
	 * Returns an appropriate output message based on size of given taskList
	 * 
	 * @param taskList
	 *            List of {@code Task} with task name containing the keyword
	 * 
	 * @return a String output message for CommandAction
	 */
	private String getOutputMsg(List<Task> taskList) {

		assert taskList != null;

		// Case 1 : List isEmpty
		if (taskList.isEmpty()) {
			return String.format(MSG_KEYWORD_NOTFOUND, _keyword);
		}

		// Case 2 : List.size > 1 (Since ID is unique)
		if (taskList.size() > 1) {
			return String.format(MSG_ISNTANCEFOUND, taskList.size(), _keyword);
		}

		// Case 3: List.size == 1
		return String.format(MSG_TASKFOUND, taskList.get(0).getName());

	}

}
```
###### logic\command\CmdUndo.java
``` java

/**
 * Command to undo a previous command 
 */

package logic.command;

public class CmdUndo extends Command {

	/*
	 * Constants
	 */
	private static final String MSG_UNDOEMPTY = "No commands to undo!";

	// Help Info
	private static final String HELP_INFO_UNDO = "Just undo...";

	/**
	 * Undo a previous command
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction execute() {
		Command toUndo = extractHistory();

		if (toUndo == null) {
			return new CommandAction(MSG_UNDOEMPTY, false, null);
		} else {
			return undoCommand(toUndo);
		}
	}

	@Override
	public CommandAction undo() {
		return null;
	}

	@Override
	public String[] getRequiredFields() {
		return new String[] {};
	}

	@Override
	public String[] getOptionalFields() {
		return new String[] {};
	}

	/**
	 * Returns a syntax message for undo command
	 * 
	 * @return a syntax message for undo command
	 */
	@Override
	public String getHelpInfo() {
		return HELP_INFO_UNDO;
	}

	/**
	 * Returns a CommandAction of undoing a previous command
	 * 
	 * @return a CommandAction of undoing a previous command
	 */
	private CommandAction undoCommand(Command toUndo) {

		assert toUndo != null;

		CommandAction undoCommandAction = toUndo.undo();
		return new CommandAction(undoCommandAction.getOutput(), false, undoCommandAction.getTaskList());
	}

}
```
###### logic\command\CmdUpdate.java
``` java

/**
 * Command to update the details (task_name, start_time, end_time, priority) of a {@code Task} 
 */

package logic.command;

import util.TimeUtil;

import java.util.logging.Level;

import constants.CmdParameters;
import parser.ParserConstants;

import taskCollections.Task;
import taskCollections.Task.FLAG_TYPE;
import taskCollections.Task.PRIORITY_TYPE;

import logger.LogHandler;

public class CmdUpdate extends Command {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_TASKIDNOTFOUND = "Specified taskID \"%1$s\" not found";
	private static final String MSG_TASKNOUPDATE = "No update was made";
	private static final String MSG_TASKUPDATED = "Updated ID: \"%1$s\"";
	private static final String MSG_INVALIDTIME = "Invalid start/end time given";

	// Help Info
	private static final String HELP_INFO_UPDATE = "<task_ID> [%1$s <task_name>] [%2$s <start_time>] "
			+ "[%3$s <end_time>][%4$s <high/normal/low/h/n/l>]";

	// Log Message
	private static final String LOG_NUMBERFORMATEXCEPTION = "\"%1$s\" is not an integer";

	// Variable constants
	private static final int INVALID_TASKID = -1;
	private static final int OPTIONAL_PARAM_EMPTY = 0;
	private static final int IS_OPTIONAL_PARAM = 1;
	private static final int NOT_OPTIONAL_PARAM = 0;
	private static final int NO_TIME = 0;
	private static final int VALID_TIME_COMPARATOR = 1;

	/*
	 * Variables for internal use
	 */
	private Task _task;
	private int _taskID;

	// variables for updating
	private String _newTaskName;
	private long _newStartTime;
	private long _newEndTime;
	private PRIORITY_TYPE _newPriority;

	// variables for undo
	private String _prevTaskName;
	private long _prevStartTime;
	private long _prevEndTime;
	private PRIORITY_TYPE _prevPriority;

	public CmdUpdate() {

	}

	/**
	 * Updates new details to a specified {@code Task}
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction execute() {

		// Check if there is a task to be updated
		if (!hasTaskToUpdate()) {
			return new CommandAction(String.format(MSG_TASKIDNOTFOUND, _taskID), false, null);
		}

		// Initialize optional parameter values
		if (hasOptionalParam(proccessOptionalFields())) {
			if (isInvalidTime(_newStartTime, _newEndTime)) {
				return new CommandAction(MSG_INVALIDTIME, false, null);
			}
		} else {
			return new CommandAction(MSG_TASKNOUPDATE, false, null);
		}

		return updateTask(_task, _newTaskName, _newStartTime, _newEndTime, _newPriority);
	}

	/**
	 * Undo the changes to a previously updated {@code Task}
	 * 
	 * @return a CommandAction
	 */
	@Override
	public CommandAction undo() {
		return updateTask(_task, _prevTaskName, _prevStartTime, _prevEndTime, _prevPriority);
	}

	@Override
	public String[] getRequiredFields() {
		return new String[] { CmdParameters.PARAM_NAME_TASK_ID };
	}

	@Override
	public String[] getOptionalFields() {
		return new String[] { CmdParameters.PARAM_NAME_TASK_SNAME, CmdParameters.PARAM_NAME_TASK_STARTTIME,
				CmdParameters.PARAM_NAME_TASK_ENDTIME, CmdParameters.PARAM_NAME_TASK_PRIORITY };
	}

	/**
	 * Returns a syntax message for update command
	 * 
	 * @return a syntax message for update command
	 */
	@Override
	public String getHelpInfo() {
		return String.format(HELP_INFO_UPDATE, ParserConstants.TASK_SPECIFIER_TASKNAME,
				ParserConstants.TASK_SPECIFIER_STARTTIME, ParserConstants.TASK_SPECIFIER_ENDTIME,
				ParserConstants.TASK_SPECIFIER_PRIORITY);
	}

	/**
	 * Process the given task ID and returns a Task of the specified ID.
	 * 
	 * @param paramTaskID
	 *            a String parameter of task ID.
	 * 
	 * @return a {@code Task} of the specified ID.
	 */
	private Task processTaskID(String paramTaskID) {
		assert paramTaskID != null && !paramTaskID.equals("");

		try {
			_taskID = Integer.parseInt(paramTaskID);
		} catch (NumberFormatException e) {
			LogHandler.getLog().log(Level.WARNING, String.format(LOG_NUMBERFORMATEXCEPTION, paramTaskID));
			_taskID = INVALID_TASKID;
		}

		return _taskTree.getTask(_taskID);
	}

	/**
	 * Check if a {@code Task} exist to be updated.
	 * 
	 * @return true if {@code Task} is not null. false if {@code Task} is null.
	 */
	private boolean hasTaskToUpdate() {

		String paramTaskID = getParameterValue(CmdParameters.PARAM_NAME_TASK_ID);
		_task = processTaskID(paramTaskID);

		if (_task == null) {
			return false;
		} else {
			return true;
		}

	}

	/**
	 * Check if there is/are optional parameter(s) given.
	 * 
	 * @return true if there is at least one optional parameter. false if there
	 *         is no optional parameter.
	 */
	private boolean hasOptionalParam(int noOfOptionalParam) {
		if (noOfOptionalParam == OPTIONAL_PARAM_EMPTY) {
			return false;
		} else {
			return true;
		}
	}

	/**
	 * Initializes {@code _newTaskName}, {@code _newStartTime},
	 * {@code _newEndTime}, {@code _newPriority}, with optional parameters
	 * values.
	 *
	 * @return number of optional parameter(s) processed.
	 */
	private int proccessOptionalFields() {

		int noOfOptionalParam = OPTIONAL_PARAM_EMPTY;

		// Initializes each variable and calculate total number of optional
		// parameter(s)
		noOfOptionalParam += processTaskName();
		noOfOptionalParam += processStartTime();
		noOfOptionalParam += processEndTime();
		noOfOptionalParam += processPriority();
		return noOfOptionalParam;

	}

	/**
	 * Initializes {@code _newTaskName} with task name optional parameters
	 * value.
	 *
	 * @return {@code IS_OPTIONAL_PARAM} if task name optional parameter is
	 *         processed. else return {@code NOT_OPTIONAL_PARAM}
	 */
	private int processTaskName() {

		String paramTaskName = getParameterValue(CmdParameters.PARAM_NAME_TASK_SNAME);
		if (paramTaskName == null || paramTaskName.equals("") || paramTaskName.equals(_task.getName())) {
			_newTaskName = _task.getName();
			return NOT_OPTIONAL_PARAM;
		} else {
			_newTaskName = paramTaskName;
			return IS_OPTIONAL_PARAM;
		}

	}

	/**
	 * Initializes {@code _newStartTime} with start time optional parameters
	 * value.
	 *
	 * @return {@code IS_OPTIONAL_PARAM} if start time optional parameter is
	 *         processed. else return {@code NOT_OPTIONAL_PARAM}
	 */
	private int processStartTime() {

		String paramStartTime = getParameterValue(CmdParameters.PARAM_NAME_TASK_STARTTIME);

		try {
			_newStartTime = Long.parseLong(paramStartTime);
			if (_newStartTime == _task.getStartTime()) {
				return NOT_OPTIONAL_PARAM;
			} else {
				return IS_OPTIONAL_PARAM;
			}
		} catch (Exception e) {
			_newStartTime = _task.getStartTime();
			return NOT_OPTIONAL_PARAM;
		}

	}

	/**
	 * Initializes {@code _newEndTime} with end time optional parameters value.
	 *
	 * @return {@code IS_OPTIONAL_PARAM} if end time optional parameter is
	 *         processed. else return {@code NOT_OPTIONAL_PARAM}
	 */
	private int processEndTime() {

		String paramEndTime = getParameterValue(CmdParameters.PARAM_NAME_TASK_ENDTIME);

		try {
			_newEndTime = Long.parseLong(paramEndTime);
			if (_newEndTime == _task.getEndTime()) {
				return NOT_OPTIONAL_PARAM;
			} else {
				return IS_OPTIONAL_PARAM;
			}
		} catch (Exception e) {
			_newEndTime = _task.getEndTime();
			return NOT_OPTIONAL_PARAM;
		}

	}

	/**
	 * Initializes {@code _newPriority} with priority optional parameters value.
	 *
	 * @return {@code IS_OPTIONAL_PARAM} if priority optional parameter is
	 *         processed. else return {@code NOT_OPTIONAL_PARAM}
	 */
	private int processPriority() {

		String paramPriority = getParameterValue(CmdParameters.PARAM_NAME_TASK_PRIORITY);

		if (paramPriority == null || paramPriority.equals("")
				|| getPriorityType(paramPriority) == _task.getPriority()) {
			_newPriority = _task.getPriority();
			return NOT_OPTIONAL_PARAM;
		} else {
			_newPriority = getPriorityType(paramPriority);
			return IS_OPTIONAL_PARAM;
		}

	}

	/**
	 * Returns a {@code PRIORITY_TYPE} according to priority parameter
	 *
	 * @param priorityParam
	 *            a String parameter of priority
	 *
	 * @return {@code IS_OPTIONAL_PARAM} if priority optional parameter is
	 *         processed. else return {@code NOT_OPTIONAL_PARAM}
	 */
	private PRIORITY_TYPE getPriorityType(String priorityParam) {

		PRIORITY_TYPE priorityType;

		switch (priorityParam) {
			case CmdParameters.PARAM_VALUE_TASK_PRIORITY_HIGH:
				priorityType = PRIORITY_TYPE.HIGH;
				break;
			case CmdParameters.PARAM_VALUE_TASK_PRIORITY_NORM:
				priorityType = PRIORITY_TYPE.NORMAL;
				break;
			case CmdParameters.PARAM_VALUE_TASK_PRIORITY_LOW:
				priorityType = PRIORITY_TYPE.LOW;
				break;
			default:
				priorityType = PRIORITY_TYPE.NORMAL;
				break;
		}

		return priorityType;

	}

	/**
	 * Checks if either start time or end time is invalid
	 *
	 * @param newStartTime
	 *            start time to be updated to Task
	 * 
	 * @param newEndTime
	 *            end time to be updated to Task
	 *
	 * @return true if either start time or end time is invalid. false if both
	 *         start time and end time are valid
	 */
	private boolean isInvalidTime(long newStartTime, long newEndTime) {

		assert newStartTime >= 0 && newEndTime >= 0;

		// Check if start time and end time is unchanged
		if (newStartTime == _task.getStartTime() && newEndTime == _task.getEndTime()) {
			return false;
		}

		// Check if start time and end time is to be removed
		if (newStartTime == NO_TIME && newEndTime == NO_TIME) {
			return false;
		}

		// Check if start time is earlier than end time
		if (TimeUtil.compareMinTime(newEndTime, newStartTime) >= VALID_TIME_COMPARATOR) {
			return false;
		}

		return true;
	}

	/**
	 * Update new details to a specified {@code Task}
	 *
	 * @param task
	 *            {@code Task} to be updated
	 * 
	 * @param newTaskName
	 *            new task name to be updated
	 * 
	 * @param newStartTime
	 *            new start time to be updated
	 * 
	 * @param newEndTime
	 *            new end time to be updated
	 * 
	 * @param newPriority
	 *            new priority to be updated
	 *
	 * @return a CommandAction of updating a {@code Task} successfully
	 * 
	 */
	private CommandAction updateTask(Task task, String newTaskName, long newStartTime, long newEndTime,
			PRIORITY_TYPE newPriority) {
		// Set previous task details
		_prevTaskName = task.getName();
		_prevStartTime = task.getStartTime();
		_prevEndTime = task.getEndTime();
		_prevPriority = task.getPriority();

		// Update task with new details
		_taskTree.updateName(task, newTaskName);
		_taskTree.updateStartTime(task, newStartTime);
		_taskTree.updateEndTime(task, newEndTime);
		_taskTree.updatePriority(task, newPriority);

		return new CommandAction(String.format(MSG_TASKUPDATED, _taskID), true, _taskTree.searchFlag(FLAG_TYPE.NULL));
	}

}
```
###### logic\command\CommandAction.java
``` java
/**
 * CommandAction is an object which contains a String output message for UI, boolean to
 * determine if command action is undoable, and a list of task(s) to be displayed in UI table,
 * for {@link TaskBuddy} to unpack 
 */

package logic.command;

import java.util.List;

import taskCollections.Task;

public class CommandAction {

	/*
	 * Variables for internal use
	 */
	private String _outputMsg;
	private boolean _isUndoable;
	private List<Task> _taskList;

	/**
	 * Constructs a new CommandAction
	 *
	 * @param outputMsg
	 *            message to be printed above the command line in UI
	 * @param isUndoable
	 *            to determine if a command action can be undone
	 * @param List {@code <Task>}
	 *            list of task(s) to be displayed in UI table
	 */
	public CommandAction(String outputMsg, boolean isUndoable, List<Task> taskList) {
		_outputMsg = outputMsg;
		_isUndoable = isUndoable;
		_taskList = taskList;
	}

	/**
	 * Returns a String message to be printed above the command line in UI
	 *
	 * @return a String message to be printed above the command line in UI
	 */
	public String getOutput() {
		return _outputMsg;
	}

	/**
	 * Returns a boolean to determine if a command action can be undone
	 *
	 * @return a boolean to determine if a command action can be undone
	 */
	public boolean isUndoable() {
		return _isUndoable;
	}

	/**
	 * Returns list of task(s) to be displayed in UI table
	 *
	 * @return a list of task(s) to be displayed in UI table
	 */
	public List<Task> getTaskList() {
		return _taskList;
	}
}
```
###### test\command\CmdAddTest.java
``` java

/**
 * Testing of CmdAdd
 */

package test.command;

import java.util.ArrayList;
import java.util.List;

import constants.CmdParameters;

import logic.command.CmdAdd;
import logic.command.Command;
import logic.command.CommandAction;

import taskCollections.Task;
import taskCollections.Task.PRIORITY_TYPE;

public class CmdAddTest {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_TASKNAMENOTGIVEN = "Please enter a task name";
	private static final String MSG_TASKADDED = "Added : %1$s";
	private static final String MSG_STARTAFTEREND = "Specified start time should be before end time";

	// Variable Constants
	private static final long INVALID_START_TIME = 1448722800000L; // 28Nov15
																	// 15:00
	private static final long VALID_START_TIME = 1448895600000L; // 30Nov15
																	// 15:00
	private static final long VALID_END_TIME = 1448780400000L; // 29Nov15
																	// 15:00
	private static final int NO_TIME = 0;
	private static final String EMPTY_STRING = "";
	private static final String TASK_NAME_1 = "task name 1";
	private static final String TASK_NAME_2 = "task name 2";

	/*
	 * Variables for internal use
	 */
	private Command _testCmdAdd;
	private CommandTestFunctions ctf;

	public CmdAddTest() {
		ctf = new CommandTestFunctions();
	}

	/**
	 * Run all available test cases for CmdAdd
	 */
	public void testCmdAdd() {
		testCmdAdd_taskName_field();
		testCmdAdd_time_field();
		testCmdAdd_priority_field();
	}

	/**
	 * Testing of CmdAdd task name field
	 */
	public void testCmdAdd_taskName_field() {
		// Initialize test variables
		CommandAction expectedCA;
		Task expectedTask;
		List<Task> expectedTaskList;

		/*
		 * Test 1: Testing task name field
		 */
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();

		// Test 1a: task name is null
		_testCmdAdd = new CmdAdd();
		setParameters(null, null, null, null);
		expectedCA = new CommandAction(MSG_TASKNAMENOTGIVEN, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 1b: task name is an empty String
		_testCmdAdd = new CmdAdd();
		setParameters(EMPTY_STRING, null, null, null);
		expectedCA = new CommandAction(MSG_TASKNAMENOTGIVEN, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 1c: task name is not empty
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, null, null, null);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, NO_TIME, NO_TIME, PRIORITY_TYPE.NORMAL);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKADDED, TASK_NAME_1), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 1d: new task name added to an existing list
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_2, null, null, null);
		expectedTask = ctf.createExpectedTask(TASK_NAME_2, NO_TIME, NO_TIME, PRIORITY_TYPE.NORMAL);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKADDED, TASK_NAME_2), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

	}

	/**
	 * Testing of CmdAdd time field
	 */
	public void testCmdAdd_time_field() {
		// Initialize test variables
		CommandAction expectedCA;
		Task expectedTask;
		List<Task> expectedTaskList;

		/*
		 * Test 2: Testing start time and end time field
		 */

		// Test 2a: start time and end time are both null
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, null, null, null);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, NO_TIME, NO_TIME, PRIORITY_TYPE.NORMAL);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKADDED, TASK_NAME_1), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 2b: start time is null, end time is valid
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, null, VALID_END_TIME + "", null);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, NO_TIME, VALID_END_TIME, PRIORITY_TYPE.NORMAL);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKADDED, TASK_NAME_1), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 2c: start time is valid, end time is null
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, INVALID_START_TIME + "", null, null);
		expectedCA = new CommandAction(MSG_STARTAFTEREND, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 2d: start time is valid, end time is valid
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, INVALID_START_TIME + "", VALID_END_TIME + "", null);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, INVALID_START_TIME, VALID_END_TIME, PRIORITY_TYPE.NORMAL);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKADDED, TASK_NAME_1), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 2e: start time is valid, end time is valid, but start time is
		// before end time
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, VALID_START_TIME + "", VALID_END_TIME + "", null);
		expectedCA = new CommandAction(MSG_STARTAFTEREND, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

	}

	/**
	 * Testing of CmdAdd priority field
	 */
	public void testCmdAdd_priority_field() {
		// Initialize test variables
		CommandAction expectedCA;
		Task expectedTask;
		List<Task> expectedTaskList;

		/*
		 * Test 3: Testing priority field
		 */

		// Test 3a: priority is null
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, null, null, null);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, NO_TIME, NO_TIME, PRIORITY_TYPE.NORMAL);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKADDED, TASK_NAME_1), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 3b: priority is HIGH
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, null, null, CmdParameters.PARAM_VALUE_TASK_PRIORITY_HIGH);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, NO_TIME, NO_TIME, PRIORITY_TYPE.HIGH);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKADDED, TASK_NAME_1), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 3c: priority is NORMAL
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, null, null, CmdParameters.PARAM_VALUE_TASK_PRIORITY_NORM);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, NO_TIME, NO_TIME, PRIORITY_TYPE.NORMAL);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKADDED, TASK_NAME_1), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

		// Test 3d: priority is LOW
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		_testCmdAdd = new CmdAdd();
		setParameters(TASK_NAME_1, null, null, CmdParameters.PARAM_VALUE_TASK_PRIORITY_LOW);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, NO_TIME, NO_TIME, PRIORITY_TYPE.LOW);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKADDED, TASK_NAME_1), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdAdd.execute());

	}

	/**
	 * Set parameters for testing
	 * 
	 * @param taskName
	 *            task name to be set as parameter
	 * 
	 * @param startTime
	 *            start time to be set as parameter
	 * 
	 * @param endTime
	 *            end time to be set as parameter
	 * 
	 * @param priority
	 *            priority to be set as parameter
	 */
	public void setParameters(String taskName, String startTime, String endTime, String priority) {
		_testCmdAdd.setParameter(CmdParameters.PARAM_NAME_TASK_NAME, taskName);
		_testCmdAdd.setParameter(CmdParameters.PARAM_NAME_TASK_STARTTIME, startTime);
		_testCmdAdd.setParameter(CmdParameters.PARAM_NAME_TASK_ENDTIME, endTime);
		_testCmdAdd.setParameter(CmdParameters.PARAM_NAME_TASK_PRIORITY, priority);
	}

}
```
###### test\command\CmdDeleteTest.java
``` java

/**
 * Testing of CmdDelete
 */

package test.command;

import java.util.ArrayList;
import java.util.List;

import constants.CmdParameters;

import logic.command.CmdAdd;
import logic.command.CmdDelete;
import logic.command.Command;
import logic.command.CommandAction;

import taskCollections.Task;

public class CmdDeleteTest {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_TASKIDNOTFOUND = "Specified taskID \"%1$s\" not found";
	private static final String MSG_TASKDELETED = "Deleted : \"%1$s\"";

	// Variable constant
	private static final int VALID_TASKID = 0;
	private static final int INVALID_TASKID = -1;
	private static final String TASKNAME = "task name";

	/*
	 * Variables for internal use
	 */
	private Command _testCmdDelete;
	private CommandTestFunctions ctf;

	public CmdDeleteTest() {
		ctf = new CommandTestFunctions();
	}

	/**
	 * Run all available test cases for CmdAdd
	 */
	public void testCmdDelete() {
		testCmdDelete_ID_field();
	}

	/**
	 * Testing of CmdDelete task ID field
	 */
	public void testCmdDelete_ID_field() {
		// Initialize test variables
		CommandAction expectedCA;
		List<Task> expectedTaskList;

		/*
		 * Test 1: Testing ID field
		 */
		ctf.initialize();
		expectedTaskList = null;

		// Test 1a: ID is null
		_testCmdDelete = new CmdDelete();
		_testCmdDelete.setParameter(CmdParameters.PARAM_NAME_TASK_ID, null);
		expectedCA = new CommandAction(String.format(MSG_TASKIDNOTFOUND, INVALID_TASKID), false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdDelete.execute());

		// Test 1b: ID is invalid
		_testCmdDelete = new CmdDelete();
		_testCmdDelete.setParameter(CmdParameters.PARAM_NAME_TASK_ID, INVALID_TASKID + "");
		expectedCA = new CommandAction(String.format(MSG_TASKIDNOTFOUND, INVALID_TASKID), false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdDelete.execute());

		// Test 1c: ID is valid, but not in list
		_testCmdDelete = new CmdDelete();
		_testCmdDelete.setParameter(CmdParameters.PARAM_NAME_TASK_ID, VALID_TASKID + "");
		expectedCA = new CommandAction(String.format(MSG_TASKIDNOTFOUND, VALID_TASKID), false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdDelete.execute());

		// Test 1d: ID is valid and is in list
		ctf.initialize();
		expectedTaskList = new ArrayList<Task>();
		addNewTask();
		_testCmdDelete = new CmdDelete();
		_testCmdDelete.setParameter(CmdParameters.PARAM_NAME_TASK_ID, VALID_TASKID + "");
		expectedCA = new CommandAction(String.format(MSG_TASKDELETED, TASKNAME), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdDelete.execute());
	}

	/**
	 * add new task to Command.xml for testing
	 * 
	 */
	public void addNewTask() {
		Command cmdAdd = new CmdAdd();
		cmdAdd.setParameter(CmdParameters.PARAM_NAME_TASK_NAME, TASKNAME);
		cmdAdd.execute();
	}

}
```
###### test\command\CmdUpdateTest.java
``` java

/**
 * Testing of CmdUpdate
 */

package test.command;

import java.util.ArrayList;
import java.util.List;

import constants.CmdParameters;

import logic.command.CmdAdd;
import logic.command.CmdUpdate;
import logic.command.Command;
import logic.command.CommandAction;

import taskCollections.Task;
import taskCollections.Task.PRIORITY_TYPE;

public class CmdUpdateTest {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_TASKIDNOTFOUND = "Specified taskID \"%1$s\" not found";
	private static final String MSG_TASKNOUPDATE = "No update was made";
	private static final String MSG_TASKUPDATED = "Updated ID: \"%1$s\"";
	private static final String MSG_INVALIDTIME = "Invalid start/end time given";

	// Variable constant
	// 28Nov15 15:00
	private static final long VALID_START_TIME = 1448722800000L;
	// 30Nov15 15:00
	private static final long INVALID_START_TIME = 1448895600000L;
	// 29Nov15 15:00
	private static final long VALID_END_TIME = 1448780400000L;
	private static final int NO_TIME = 0;

	private static final int VALID_TASKID = 0;
	private static final int INVALID_TASKID = -1;
	private static final String EMPTY_STRING = "";
	private static final String TASK_NAME_1 = "task name 1";
	private static final String TASK_NAME_2 = "task name 2";

	/*
	 * Variables for internal use
	 */
	private Command _testCmdUpdate;
	private CommandTestFunctions ctf;

	public CmdUpdateTest() {
		ctf = new CommandTestFunctions();
	}

	/**
	 * Run all available test cases for CmdAdd
	 */
	public void testCmdUpdate() {
		testCmdUpdate_taskID_field();
		testCmdUpdate_taskName_field();
		testCmdUpdate_time_field();
		testCmdUpdate_priority_field();
	}

	/**
	 * Testing of CmdAdd task ID field
	 */
	public void testCmdUpdate_taskID_field() {
		// Initialize test variables
		CommandAction expectedCA;
		List<Task> expectedTaskList;

		/*
		 * Test 1: Testing ID field
		 */
		ctf.initialize();
		expectedTaskList = null;

		// Test 1a: ID is null
		_testCmdUpdate = new CmdUpdate();
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_ID, null);
		expectedCA = new CommandAction(String.format(MSG_TASKIDNOTFOUND, INVALID_TASKID), false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		// Test 1b: ID is invalid
		_testCmdUpdate = new CmdUpdate();
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_ID, INVALID_TASKID + "");
		expectedCA = new CommandAction(String.format(MSG_TASKIDNOTFOUND, INVALID_TASKID), false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		// Test 1c: ID is valid, but not in list
		_testCmdUpdate = new CmdUpdate();
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_ID, VALID_TASKID + "");
		expectedCA = new CommandAction(String.format(MSG_TASKIDNOTFOUND, VALID_TASKID), false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		// Test 1d: ID is valid and is in list, but not update changes
		addNewTask(TASK_NAME_1);
		_testCmdUpdate = new CmdUpdate();
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_ID, VALID_TASKID + "");
		expectedCA = new CommandAction(MSG_TASKNOUPDATE, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

	}

	/**
	 * Testing of CmdUpdate task name field
	 */
	public void testCmdUpdate_taskName_field() {
		// Initialize test variables
		CommandAction expectedCA;
		Task expectedTask;
		List<Task> expectedTaskList;

		/*
		 * Test 2: Testing task name field (all ID are valid)
		 */
		ctf.initialize();
		expectedTaskList = null;
		addNewTask(TASK_NAME_1);

		// Test 2a: task name is null
		_testCmdUpdate = new CmdUpdate();
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_ID, VALID_TASKID + "");
		expectedCA = new CommandAction(MSG_TASKNOUPDATE, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		// Test 2b: task name is an empty String
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", EMPTY_STRING, null, null, null);
		expectedCA = new CommandAction(MSG_TASKNOUPDATE, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		// Test 2c: new task name is same as current task name (no changes)
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_1, null, null, null);
		expectedCA = new CommandAction(MSG_TASKNOUPDATE, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		// Test 2d: new task name is different from current task name (changes
		// made)
		expectedTaskList = new ArrayList<Task>();
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_2, null, null, null);
		expectedTask = ctf.createExpectedTask(TASK_NAME_2, NO_TIME, NO_TIME, PRIORITY_TYPE.NORMAL);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKUPDATED, VALID_TASKID), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

	}

	/**
	 * Testing of CmdUpdate time field
	 */
	public void testCmdUpdate_time_field() {
		// Initialize test variables
		CommandAction expectedCA;
		Task expectedTask;
		List<Task> expectedTaskList;

		/*
		 * Test 3: Testing time field (all ID are valid)
		 */
		ctf.initialize();
		expectedTaskList = null;
		addNewTask(TASK_NAME_1);

		// Test 3a: start time and end time are both null
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_1, null, null, null);
		expectedCA = new CommandAction(MSG_TASKNOUPDATE, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		// Test 3b: valid start time without end time
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_1, VALID_START_TIME + "", null, null);
		expectedCA = new CommandAction(MSG_INVALIDTIME, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		// Test 3c: start time after end time
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_1, INVALID_START_TIME + "", VALID_END_TIME + "", null);
		expectedCA = new CommandAction(MSG_INVALIDTIME, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		expectedTaskList = new ArrayList<Task>();
		// Test 3d: start time before end time
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_1, VALID_START_TIME + "", VALID_END_TIME + "", null);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, VALID_START_TIME, VALID_END_TIME, PRIORITY_TYPE.NORMAL);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKUPDATED, VALID_TASKID), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());
	}

	/**
	 * Testing of CmdUpdate priority field
	 */
	public void testCmdUpdate_priority_field() {
		// Initialize test variables
		CommandAction expectedCA;
		Task expectedTask;
		List<Task> expectedTaskList;

		/*
		 * Test 4: Testing priority field (all ID are valid)(default priority is
		 * normal)
		 */
		ctf.initialize();
		expectedTaskList = null;
		addNewTask(TASK_NAME_1);

		// Test 4a: priority is null
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_1, null, null, null);
		expectedCA = new CommandAction(MSG_TASKNOUPDATE, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		// Test 4b: priority is normal
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_1, null, null, CmdParameters.PARAM_VALUE_TASK_PRIORITY_NORM);
		expectedCA = new CommandAction(MSG_TASKNOUPDATE, false, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());

		expectedTaskList = new ArrayList<Task>();
		// Test 4c: priority is high
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_1, null, null, CmdParameters.PARAM_VALUE_TASK_PRIORITY_HIGH);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, NO_TIME, NO_TIME, PRIORITY_TYPE.HIGH);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKUPDATED, VALID_TASKID), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());
		
		expectedTaskList = new ArrayList<Task>();
		// Test 4d: priority is low
		_testCmdUpdate = new CmdUpdate();
		setParameters(VALID_TASKID + "", TASK_NAME_1, null, null, CmdParameters.PARAM_VALUE_TASK_PRIORITY_LOW);
		expectedTask = ctf.createExpectedTask(TASK_NAME_1, NO_TIME, NO_TIME, PRIORITY_TYPE.LOW);
		expectedTaskList.add(expectedTask);
		expectedCA = new CommandAction(String.format(MSG_TASKUPDATED, VALID_TASKID), true, expectedTaskList);
		ctf.assertCommandAction(expectedCA, _testCmdUpdate.execute());
	}

	/**
	 * add new task to Command.xml for testing
	 * 
	 * @param taskName
	 *            task name of new task
	 */
	public void addNewTask(String taskName) {
		Command cmdAdd = new CmdAdd();
		cmdAdd.setParameter(CmdParameters.PARAM_NAME_TASK_NAME, taskName);
		cmdAdd.execute();
	}

	/**
	 * Set parameters for testing
	 * 
	 * @param taskID
	 *            task ID to be set as parameter
	 * 
	 * @param taskName
	 *            task name to be set as parameter
	 * 
	 * @param startTime
	 *            start time to be set as parameter
	 * 
	 * @param endTime
	 *            end time to be set as parameter
	 * 
	 * @param priority
	 *            priority to be set as parameter
	 */
	public void setParameters(String taskID, String taskName, String startTime, String endTime, String priority) {
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_ID, taskID);
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_SNAME, taskName);
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_STARTTIME, startTime);
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_ENDTIME, endTime);
		_testCmdUpdate.setParameter(CmdParameters.PARAM_NAME_TASK_PRIORITY, priority);
	}

}
```
###### test\command\CommandTest.java
``` java

/**
 * Testing of Command
 */

package test.command;

//JUnit
import org.junit.Test;

public class CommandTest {

	/*
	 * Variables for internal use
	 */
	CmdAddTest _CmdAddTest;
	CmdDeleteTest _CmdDeleteTest;
	CmdUpdateTest _CmdUpdateTest;

	@Test
	public void testCommands() {
		testCmdAdd();
		testCmdDelete();
		testCmdUpdate();
	}

	/**
	 * Testing of CmdAdd
	 */
	public void testCmdAdd() {
		_CmdAddTest = new CmdAddTest();
		_CmdAddTest.testCmdAdd();
	}

	/**
	 * Testing of CmdDelete
	 */
	public void testCmdDelete() {
		_CmdDeleteTest = new CmdDeleteTest();
		_CmdDeleteTest.testCmdDelete();
	}

	/**
	 * Testing of CmdUpdate
	 */
	public void testCmdUpdate() {
		_CmdUpdateTest = new CmdUpdateTest();
		_CmdUpdateTest.testCmdUpdate();
	}

}
```
###### test\command\CommandTestFunctions.java
``` java

/**
 * Methods for initializing test variables and asserting CommandAction
 */

package test.command;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.FileNotFoundException;
import java.io.PrintWriter;

import logic.command.Command;
import logic.command.CommandAction;

import taskCollections.Task;
import taskCollections.TaskTree;

import parser.TimeProcessor;

public class CommandTestFunctions {

	// Variable constants
	private static final String COMMAND_TEST_FILE = "src/test/command/CommandTest.xml";
	private static final String DEFAULT_FILE_CONTENT = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>"
			+ "\n<tasklist>\n</tasklist>\n";
	
	/*
	 * Variables for internal use
	 */
	private TimeProcessor tp;
	
	public CommandTestFunctions(){
		tp = TimeProcessor.getInstance();
	}
	
	/**
	 * Assert if contents of CommandAction from test results are equal to
	 * expected results.
	 *
	 * @param expectedCA
	 *            CommandAction of expected result
	 *
	 * @param testCA
	 *            CommandAction of test result
	 */
	public void assertCommandAction(CommandAction expectedCA, CommandAction testCA) {

		// Assert String outputMsg
		assertEquals(expectedCA.getOutput(), testCA.getOutput());

		// Assert boolean isUndoable
		if (expectedCA.isUndoable()) {
			assertTrue(testCA.isUndoable()); // assert true if expected is true
		} else {
			assertFalse(testCA.isUndoable());// assert false if expected is
												// false
		}

		// Assert List<Task> taskList
		assertEquals(expectedCA.getTaskList(), testCA.getTaskList());

	}

	/**
	 * Initialization of necessary variables for testing (i.e. TaskTree,
	 * Command.xml)
	 */
	public void initialize() {
		resetCommandXML();
		Task.resetTaskClassId();
		TaskTree.newTaskTree(COMMAND_TEST_FILE);
		Command.init();	
	}

	/**
	 * Reset Command.xml in a clean state (without any {@code Task})
	 */
	public void resetCommandXML() {
		try {
			PrintWriter pw = new PrintWriter(COMMAND_TEST_FILE);
			pw.write(DEFAULT_FILE_CONTENT);
			pw.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

	}

	/**
	 * Creates and returns an expected {@code Task}
	 *
	 * @param taskName
	 *            task name of expected {@code Task}
	 *
	 * @param startTime
	 *            start time of expected {@code Task}
	 * 
	 * @param endTime
	 *            end time of expected {@code Task}
	 * 
	 * @param priority
	 *            priority of expected {@code Task}
	 * 
	 * @return an expected {@code Task} created with given parameters.
	 */
	public Task createExpectedTask(String taskName, long startTime, long endTime, Task.PRIORITY_TYPE priority) {
		Task expectedTask = new Task(taskName, startTime, endTime, Task.FLAG_TYPE.NULL, priority);
		// To match with the appropriate task ID
		expectedTask.setId(expectedTask.getId() + 1);
		return expectedTask;
	}
	
	/**
	 * Utilize TimeProcessor to resolve time in String format to long
	 *
	 * @param time
	 *            time in String format
	 * 
	 * @return time in long format
	 */
	public long resolveTime(String time){
		return tp.resolveTime(time);
	}
}
```
