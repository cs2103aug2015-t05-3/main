# A0126394B
###### logic\TaskBuddy.java
``` java
	/**
	 * Displays the number of task counts for overdue, pending, and completed
	 */
	private static void setUITasksCount() {
		int doneCount = _taskTree.getFlagCount(FLAG_TYPE.DONE);
		int pendingCount = _taskTree.size() - doneCount;
		int overdueCount = _taskTree.getOverdueCount();

		UIHelper.setDoneCount(doneCount);
		UIHelper.setPendingCount(pendingCount);
		UIHelper.setOverdueCount(overdueCount);
	}

	/**
	 * Performs necessary actions from the command executed
	 * @param action
	 * 			The result after executing a command
	 * @param executed
	 * 			The command which was executed
	 */
	private static void resolveCmdAction(CommandAction action, Command executed) {
		String outputMsg = action.getOutput();
		List<Task> tasksToDisplay = action.getTaskList();

		if (outputMsg != null) { // Display the message to display after executing a cmd
			UIHelper.setOutputMsg(outputMsg);
		}
		if (tasksToDisplay != null) { // The list of tasks after executing a cmd
			UIHelper.setTableOutput(tasksToDisplay);
		}
		if (action.isUndoable()) { // Add to the list of history if it's undoable
			Command.addHistory(executed);
		}
	}

	private static String getInput() {
		return UIHelper.getUserInput();
	}

}
```
###### taskCollections\Attributes.java
``` java
package taskCollections;

import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;

/**
 * A list of constants used to identify a specify attribute type. These
 * constants are used for differentiating {@code treeType} for
 * {@code TaskCollection} and {@code TaskTree}.
 *
 * @see TaskTree
 * @see Task
 *
 * @author amoshydra
 */
public final class Attributes {

	/**
	 * Attribute type constants used for attributes identification
	 */
	public enum TYPE {
		NAME(0), START_TIME(1), END_TIME(2), FLAG(3), PRIORITY(4), ID(5);

		private final int value;

		private TYPE(int value) {
			this.value = value;
		}

		public int getValue() {
			return value;
		}

		private static final Map<Integer, TYPE> lookup = new HashMap<Integer, TYPE>();

		static {
			for (TYPE t : EnumSet.allOf(TYPE.class))
				lookup.put(t.getValue(), t);
		}

		static TYPE get(int value) {
			return lookup.get(value);
		}
	};

	final static int NUM_OF_ATTRIBUTES = 6;
}
```
###### taskCollections\comparators\EndTimeComparator.java
``` java
package taskCollections.comparators;

import java.util.Comparator;

import taskCollections.Task;

/**
 * Provide {@code tds.Task} a comparator for the end time attribute
 *
 * @author amoshydra
 */
public class EndTimeComparator implements Comparator<Task> {
	@Override
	public int compare(Task lhs, Task rhs) {
		return lhs.compareEndTimeTo(rhs);
	}
}
```
###### taskCollections\comparators\FlagComparator.java
``` java
package taskCollections.comparators;

import java.util.Comparator;

import taskCollections.Task;

/**
 * Provide {@code tds.Task} a comparator for the end time attribute
 *
 * @author amoshydra
 */
public class FlagComparator implements Comparator<Task> {
	@Override
	public int compare(Task lhs, Task rhs) {
		return lhs.compareFlagTo(rhs);
	}
}
```
###### taskCollections\comparators\IdComparator.java
``` java
package taskCollections.comparators;

import java.util.Comparator;

import taskCollections.Task;

/**
 * Provide {@code tds.Task} a comparator for the ID attribute
 *
 * @author amoshydra
 */
public class IdComparator implements Comparator<Task> {
	@Override
	public int compare(Task lhs, Task rhs) {
		return lhs.compareIdTo(rhs);
	}
}
```
###### taskCollections\comparators\NameComparator.java
``` java
package taskCollections.comparators;

import java.util.Comparator;

import taskCollections.Task;

/**
 * Provide {@code tds.Task} a comparator for the name attribute
 *
 * @author amoshydra
 */
public class NameComparator implements Comparator<Task> {
	@Override
    public int compare(Task lhs, Task rhs) {
        return lhs.compareNameTo(rhs);
    }
}
```
###### taskCollections\comparators\PriorityComparator.java
``` java
package taskCollections.comparators;

import java.util.Comparator;

import taskCollections.Task;

/**
 * Provide {@code tds.Task} a comparator for the priority attribute
 *
 * @author amoshydra
 */
public class PriorityComparator implements Comparator<Task> {
	@Override
    public int compare(Task lhs, Task rhs) {
		return lhs.comparePriorityTo(rhs);
    }
}
```
###### taskCollections\comparators\StartTimeComparator.java
``` java
package taskCollections.comparators;

import java.util.Comparator;

import taskCollections.Task;

/**
 * Provide {@code tds.Task} a comparator for the start time attribute
 *
 * @author amoshydra
 */
public class StartTimeComparator implements Comparator<Task> {
	@Override
    public int compare(Task lhs, Task rhs) {
		return lhs.compareStartTimeTo(rhs);
    }
}
```
###### taskCollections\comparators\TimeComparator.java
``` java
package taskCollections.comparators;

import java.util.Comparator;

import taskCollections.Task;

/**
 * Provide {@code tds.Task} a comparator for the end time attribute
 *
 * @author amoshydra
 */
public class TimeComparator implements Comparator<Task> {
	@Override
	public int compare(Task lhs, Task rhs) {
		return lhs.compareTimeTo(rhs);
	}
}
```
###### taskCollections\Task.java
``` java
package taskCollections;

import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;

/**
 * A task object used to store task name, time and different attributes.
 *
 * @author amoshydra
 */
public class Task implements Comparable<Task> {
	private static int taskNumber = 0;

	/**
	 * Field value constant for flag attribute.
	 */
	public enum FLAG_TYPE {
		NULL(0), DONE(1);

		private final int value;

		private FLAG_TYPE(int value) {
			this.value = value;
		}

		int getValue() {
			return value;
		}

		private static final Map<Integer, FLAG_TYPE> lookup = new HashMap<Integer, FLAG_TYPE>();

		static {
			for (FLAG_TYPE f : EnumSet.allOf(FLAG_TYPE.class))
				lookup.put(f.getValue(), f);
		}

		static FLAG_TYPE get(int value) {
			return lookup.get(value);
		}
	};

	/**
	 * Field value constant for priority attribute.
	 */
	public enum PRIORITY_TYPE {
		HIGH(0), NORMAL(1), LOW(2);

		private final int value;

		private PRIORITY_TYPE(int value) {
			this.value = value;
		}

		int getValue() {
			return value;
		}

		private static final Map<Integer, PRIORITY_TYPE> lookup = new HashMap<Integer, PRIORITY_TYPE>();

		static {
			for (PRIORITY_TYPE p : EnumSet.allOf(PRIORITY_TYPE.class))
				lookup.put(p.getValue(), p);
		}

		static PRIORITY_TYPE get(int value) {
			return lookup.get(value);
		}
	};

	/**
	 * Field value for start time or end time attribute indicating an empty
	 * date.
	 */
	public final static int DATE_NULL = 0;
	public final static int DATE_START = 1;
	private final static String EMPTY_STRING = "";
	private final static String TO_STRING_DELIMETER = "|";
	private final static String TO_STRING_START = "";
	private final static String TO_STRING_END = "";

	private int id;
	private String name;
	private String description;
	private long startTime;
	private long endTime;
	private FLAG_TYPE flag;
	private PRIORITY_TYPE priority;

	/**
	 * Initializes a newly created {@code Task} object so that it store the
	 * name, starting time, ending time, flag and priority as the argument. An
	 * internal ID will be used to differentiate duplicated value.
	 *
	 * @param name
	 *            the name of the newly constructed {@code Task}
	 * @param startTime
	 *            the starting time of the newly constructed {@code Task} in
	 *            UNIX format
	 * @param endTime
	 *            the ending time of the newly constructed {@code Task} in UNIX
	 *            format
	 * @param flag
	 *            the given flag field; Task marked as done is specified with
	 *            this flag.
	 * @param priority
	 *            the given priority field;
	 *
	 */
	public Task(String name, long startTime, long endTime, FLAG_TYPE flag, PRIORITY_TYPE priority) {
		this(name, EMPTY_STRING, startTime, endTime, flag, priority);
	}

	/**
	 * Initializes a newly created {@code Task} object so that it store the
	 * name, starting time, ending time, flag and priority as the argument. The
	 * ID will be specified through fileProcessor only. Do not use this to add
	 * new task from user.
	 *
	 * @param id
	 *            the index number used to identify this task.
	 * @param name
	 *            the name of the newly constructed {@code Task}
	 * @param startTime
	 *            the starting time of the newly constructed {@code Task} in
	 *            UNIX format
	 * @param endTime
	 *            the ending time of the newly constructed {@code Task} in UNIX
	 *            format
	 * @param flag
	 *            the given flag field; Task marked as done is specified with
	 *            this flag.
	 * @param priority
	 *            the given priority field;
	 *
	 */
	public Task(int id, String name, long startTime, long endTime, FLAG_TYPE flag, PRIORITY_TYPE priority) {
		this(id, name, EMPTY_STRING, startTime, endTime, flag, priority);
	}

	/**
	 * Initializes a newly created {@code Task} object so that it store the
	 * name, starting time, ending time, flag and priority as the argument. The
	 * ID will be specified through fileProcessor only. Do not use this to add
	 * new task from user.
	 *
	 * @param id
	 *            the index number used to identify this task.
	 * @param name
	 *            the name of the newly constructed {@code Task}
	 * @param description
	 *            the description of the newly constructed {@code Task}
	 * @param startTime
	 *            the starting time of the newly constructed {@code Task} in
	 *            UNIX format
	 * @param endTime
	 *            the ending time of the newly constructed {@code Task} in UNIX
	 *            format
	 * @param flag
	 *            the given flag field; Task marked as done is specified with
	 *            this flag.
	 * @param priority
	 *            the given priority field;
	 *
	 * @deprecated Description field is deprecated. Use the original constructor
	 *             without description instead.
	 *
	 */
	public Task(int id, String name, String description, long startTime, long endTime, FLAG_TYPE flag,
			PRIORITY_TYPE priority) {

		this.id = id;
		if (id >= taskNumber) {
			taskNumber = id;
			taskNumber++;
		}

		this.name = name;
		this.description = description;
		this.startTime = startTime;
		this.endTime = endTime;
		this.flag = flag;
		this.priority = priority;
	}

	/**
	 * Initializes a newly created {@code Task} object so that it store the
	 * name, starting time, ending time, flag and priority as the argument. An
	 * internal ID will be used to differentiate duplicated value.
	 *
	 * @param name
	 *            the name of the newly constructed {@code Task}
	 * @param description
	 *            the description of the newly constructed {@code Task}
	 * @param startTime
	 *            the starting time of the newly constructed {@code Task} in
	 *            UNIX format
	 * @param endTime
	 *            the ending time of the newly constructed {@code Task} in UNIX
	 *            format
	 * @param flag
	 *            the given flag field; Task marked as done is specified with
	 *            this flag.
	 * @param priority
	 *            the given priority field;
	 *
	 * @deprecated Description field will be deprecated. Use the original
	 *             constructor without description instead.
	 *
	 */
	public Task(String name, String description, long startTime, long endTime, FLAG_TYPE flag, PRIORITY_TYPE priority) {
		this.id = taskNumber++;
		this.name = name;
		this.description = description;
		this.startTime = startTime;
		this.endTime = endTime;
		this.flag = flag;
		this.priority = priority;
	}

	static Task getVirtualTask() {
		Task temp = new Task(taskNumber, EMPTY_STRING, EMPTY_STRING, DATE_NULL, DATE_NULL, FLAG_TYPE.NULL,
				PRIORITY_TYPE.NORMAL);
		taskNumber--;
		return temp;
	}

	/**
	 * Returns the id of this task in {@code int}.
	 *
	 * @return the id
	 */
	public int getId() {
		return id;
	}

	/**
	 * Returns the name of this task in {@code String}.
	 *
	 * @return the name of this task.
	 */
	public String getName() {
		return name;
	}

	/**
	 * Returns the name of this task in {@code String}.
	 *
	 * @return the description of this task.
	 * @deprecated Description field is deprecated.
	 */
	public String getDescription() {
		return description;
	}

	/**
	 * Returns the start time of this task in {@code long}.
	 *
	 * @return the start time of this task.
	 */
	public long getStartTime() {
		return startTime;
	}

	/**
	 * Returns the end time of this task in {@code long}.
	 *
	 * @return the end time of this task.
	 */
	public long getEndTime() {
		return endTime;
	}

	/**
	 * Returns the flag of this task in {@code int}.
	 *
	 * @return the flag of this task.
	 */
	public FLAG_TYPE getFlag() {
		return flag;
	}

	/**
	 * Returns the priority of this task in {@code int}.
	 *
	 * @return the priority of this task.
	 */
	public PRIORITY_TYPE getPriority() {
		return priority;
	}

	/**
	 * Change the id of this task.
	 *
	 * @param id
	 *            the new id for the task.
	 */
	public void setId(int id) {
		this.id = id;

	}

	/**
	 * Change the name of this task.
	 *
	 * @param name
	 *            the new name for the task.
	 */
	void setName(String name) {
		this.name = name;
	}

	/**
	 * Change the description of this task.
	 *
	 * @param description
	 *            the new description for the task.
	 * @deprecated Description field is deprecated.
	 */
	void setDescription(String description) {
		this.description = description;
	}

	/**
	 * Change the start time of this task.
	 *
	 * @param startTime
	 *            the new start time for the task.
	 */
	void setStartTime(long startTime) {
		this.startTime = startTime;
	}

	/**
	 * Change the end time of this task.
	 *
	 * @param endTime
	 *            the new end time for the task.
	 */
	void setEndTime(long endTime) {
		this.endTime = endTime;
	}

	/**
	 * Change the flag of this task.
	 *
	 * @param flag
	 *            the new flag for the task.
	 */
	void setFlag(FLAG_TYPE flag) {
		this.flag = flag;
	}

	/**
	 * Change the priority of this task.
	 *
	 * @param priority
	 *            the new priority for the task.
	 */
	void setPriority(PRIORITY_TYPE priority) {
		this.priority = priority;
	}

	/**
	 * @return a hash code value for this object enumerated using the ID of this
	 *         {@code Task}.
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + (int) (id ^ (id >>> 32));
		return result;
	}

	/**
	 * Determines whether or not two task are equal. The two tasks are equal if
	 * the values name, start time, end time, flag and priority are equal.
	 *
	 * @return {@code true} if the object to be compared is an instance of Task
	 *         and has the same attributes; false otherwise.
	 */
	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof Task))
			return false;
		if (obj == this)
			return true;

		Task rhs = (Task) obj;
		return (name.equals(rhs.name)) && (startTime == rhs.startTime) && (endTime == rhs.endTime) && (flag == rhs.flag)
				&& (priority == rhs.priority);
	}

	/**
	 * Compares this {@code Task} instance with another based on the order they
	 * are created.
	 *
	 * @return the value 0 if this {@code Task} is equal to the argument
	 *         {@code Task}; a value less than 0 if this {@code Task} is created
	 *         earlier than the argument {@code Task}; and a value greater than
	 *         0 if this {@code Task} is created later than the argument
	 *         {@code Task}.
	 */
	@Override
	public int compareTo(Task rhs) {
		return this.compareIdTo(rhs);
	}

	/**
	 * Compares this {@code Task} instance with another to generate an array of
	 * check bits.
	 *
	 * @param rhs
	 *            a {@code Task} to be compared with this {@code Task}
	 *
	 * @return a boolean array with all element as {@code true} if the
	 *         {@code Task} is identical to the other; A difference in
	 *         attributes between two task will cause a boolean in the array to
	 *         become false.
	 */
	public boolean[] getAttributesDiff(Task rhs) {
		boolean[] checkBits = new boolean[Attributes.NUM_OF_ATTRIBUTES];

		checkBits[Attributes.TYPE.NAME.getValue()] = (this.name.equals(rhs.name));
		checkBits[Attributes.TYPE.START_TIME.getValue()] = (this.startTime - rhs.startTime == 0);
		checkBits[Attributes.TYPE.END_TIME.getValue()] = (this.endTime - rhs.endTime == 0);
		checkBits[Attributes.TYPE.FLAG.getValue()] = (this.flag.value - rhs.flag.value == 0);
		checkBits[Attributes.TYPE.PRIORITY.getValue()] = (this.priority.value - rhs.priority.value == 0);
		checkBits[Attributes.TYPE.ID.getValue()] = (this.compareIdTo(rhs) == 0);

		return checkBits;
	}

	/**
	 * Compares the name of this {@code Task} instance with another.
	 *
	 * @param rhs
	 *            a {@code Task} to be compared with this {@code Task}
	 *
	 * @return the value 0 if the name of this {@code Task} is equal to the
	 *         argument {@code Task}; a value less than 0 if this name is
	 *         lexicographically less than the argument name; a value greater
	 *         than 0 if this name is lexicographically greater than the
	 *         argument name.
	 */
	public int compareNameTo(Task rhs) {
		int result = this.name.compareTo(rhs.name);
		return handleDuplicatedAttributes(this, rhs, result);
	}

	/**
	 * Compares the starting time of this {@code Task} instance with another.
	 *
	 * @param rhs
	 *            a {@code Task} to be compared with this {@code Task}
	 *
	 * @return the value 0 if the starting time of this {@code Task} is equal to
	 *         the argument {@code Task}; a value less than 0 if this starting
	 *         time is numerically less than the argument starting time; a value
	 *         greater than 0 this starting time is numerically greater than the
	 *         argument starting time.
	 */
	public int compareStartTimeTo(Task rhs) {
		Long startTimeLongThis = new Long(this.startTime);
		Long startTimeLongRhs = new Long(rhs.startTime);
		int result = startTimeLongThis.compareTo(startTimeLongRhs);
		return handleDuplicatedAttributes(this, rhs, result);
	}

	/**
	 * Compares the ending time of this {@code Task} instance with another.
	 *
	 * @param rhs
	 *            a {@code Task} to be compared with this {@code Task}
	 *
	 * @return the value 0 if the ending time of this {@code Task} is equal to
	 *         the argument {@code Task}; a value less than 0 if this ending
	 *         time is numerically less than the argument ending time; a value
	 *         greater than 0 this ending time is numerically greater than the
	 *         argument ending time.
	 */
	public int compareEndTimeTo(Task rhs) {
		Long endTimeLongThis = new Long(this.endTime);
		Long endTimeLongRhs = new Long(rhs.endTime);
		int result = endTimeLongThis.compareTo(endTimeLongRhs);
		return handleDuplicatedAttributes(this, rhs, result);
	}

	/**
	 * Compares the starting and ending time of this {@code Task} instance with
	 * another.
	 *
	 * @param rhs
	 *            a {@code Task} to be compared with this {@code Task}
	 *
	 * @return the value 0 if the time of this {@code Task} is equal to the
	 *         argument {@code Task}; a value less than 0 if this time is
	 *         numerically less than the argument time; a value greater than 0
	 *         this time is numerically greater than the argument time.
	 */
	public int compareTimeTo(Task rhs) {

		Long thisTime = this.getStartTime();
		if (thisTime == Task.DATE_NULL) {
			thisTime = this.getEndTime();
		}

		Long rhsTime = rhs.getStartTime();
		if (rhsTime == Task.DATE_NULL) {
			rhsTime = rhs.getEndTime();
		}

		int result = thisTime.compareTo(rhsTime);
		return handleDuplicatedAttributes(this, rhs, result);
	}

	/**
	 * Compares the flag of this {@code Task} instance with another.
	 *
	 * @param rhs
	 *            a {@code Task} to be compared with this {@code Task}
	 *
	 * @return the value 0 if the flag of this {@code Task} is equal to the
	 *         argument {@code Task}; a value less than 0 if this flag time is
	 *         numerically less than the argument flag; a value greater than 0
	 *         this flag is numerically greater than the argument flag.
	 */
	public int compareFlagTo(Task rhs) {
		int result = this.flag.value - rhs.flag.value;
		return handleDuplicatedAttributes(this, rhs, result);
	}

	/**
	 * Compares the priority of this {@code Task} instance with another.
	 *
	 * @param rhs
	 *            a {@code Task} to be compared with this {@code Task}
	 *
	 * @return the value 0 if the priority of this {@code Task} is equal to the
	 *         argument {@code Task}; a value less than 0 if this priority time
	 *         is numerically less than the argument priority; a value greater
	 *         than 0 this priority is numerically greater than the argument
	 *         priority.
	 */
	public int comparePriorityTo(Task rhs) {
		int result = this.priority.value - rhs.priority.value;
		return handleDuplicatedAttributes(this, rhs, result);
	}

	/**
	 * Compares the ID of this {@code Task} instance with another.
	 *
	 * @param rhs
	 *            a {@code Task} to be compared with this {@code Task}
	 *
	 * @return the value 0 if the ID of this {@code Task} is equal to the
	 *         argument {@code Task}; a value less than 0 if this ID is
	 *         numerically less than the argument ID; a value greater than 0
	 *         this ID is numerically greater than the argument ID.
	 */
	public int compareIdTo(Task rhs) {
		return (this.id - rhs.id);
	}

	/**
	 * Allow comparator to differentiate two duplicated attributes via its ID of
	 * creation
	 *
	 * @param rhs
	 *            a {@code Task} to be compared with this {@code Task}
	 * @param result
	 *            result obtained from previous comparison
	 *
	 * @return the original result if it is already different. Otherwise, the
	 *         difference in ID is returned
	 */
	private static int handleDuplicatedAttributes(Task lhs, Task rhs, int result) {
		if (result == 0) {
			return lhs.compareIdTo(rhs);
		} else {
			return result;
		}
	}

	/**
	 * Allow Task class ID to be reset to a desired ID. This method is intended
	 * for internal testing only.
	 *
	 * @param resetCountId
	 *            ID to be reset to
	 */
	public static void resetTaskClassId(int resetCountId) {
		taskNumber = resetCountId;
	}

	/**
	 * Allow Task class ID to be reset to its starting value, 0. This method is
	 * intended for internal testing only.
	 *
	 */
	public static void resetTaskClassId() {
		resetTaskClassId(0);
	}

	/**
	 * Represent this {@code Task} into a {@code String} format
	 *
	 * @return a string representation of this task in the format such as:
	 *
	 *         <pre>
	 *         name | startTime | endTime | flag | priority
	 *         </pre>
	 */
	@Override
	public String toString() {
		return TO_STRING_START + id + TO_STRING_DELIMETER + name + TO_STRING_DELIMETER + startTime + TO_STRING_DELIMETER
				+ endTime + TO_STRING_DELIMETER + flag + TO_STRING_DELIMETER + priority + TO_STRING_END;
	}
}
```
###### taskCollections\TaskTree.java
``` java
package taskCollections;

import java.util.List;
import java.util.TreeSet;

import storage.TaskFileHandler;
import taskCollections.Attributes;
import taskCollections.Attributes.TYPE;
import taskCollections.Task.FLAG_TYPE;
import taskCollections.Task.PRIORITY_TYPE;
import taskCollections.comparators.*;

import java.util.ArrayList;

/**
 * Provides methods for storing and manipulating {@code Task} via
 * {@code TreeSet}.
 *
 * @see Task
 * @see Attributes
 *
 * @author amoshydra
 */
public class TaskTree {

	private static TaskTree _taskTree;
	private static ArrayList<TreeSet<Task>> _taskTrees;
	private static int _taskTreeSize;
	private static TaskFileHandler _fileHandler;

	// TaskTree attributes type
	private static final int TASK_NAME_TREE = Attributes.TYPE.NAME.getValue();
	private static final int TASK_START_TIME_TREE = Attributes.TYPE.START_TIME.getValue();
	private static final int TASK_END_TIME_TREE = Attributes.TYPE.END_TIME.getValue();
	private static final int TASK_FLAG_TREE = Attributes.TYPE.FLAG.getValue();
	private static final int TASK_PRIORITY_TREE = Attributes.TYPE.PRIORITY.getValue();
	private static final int TASK_ID_TREE = Attributes.TYPE.ID.getValue();
	private static final int SIZE_OF_TASK_TREES = Attributes.NUM_OF_ATTRIBUTES;

	// Message Constants
	private final String MSG_ERR_SEARCH_TERM_EMPTY = "Search term is empty";

	// For managing comparable argument during query
	private static Task fromValueHandler;

	private final String TO_STRING_OPEN = "[";
	private final String TO_STRING_CLOSE = "]";
	private final String TO_STRING_DELIMETER = ",";

	// Prevent instantiation of this constructor
	private TaskTree() {
	}

	// Constructor of TaskTree
	/**
	 * Initialize a new, empty tree set, sorted according to the ordering of
	 * each attributes in the task.
	 *
	 * @param taskFilePath
	 *            directed to the storage XML file for tasks.
	 *
	 */
	private static boolean init(String taskFilePath) {

		_taskTree = new TaskTree();

		_taskTreeSize = 0;
		_taskTrees = new ArrayList<TreeSet<Task>>(SIZE_OF_TASK_TREES);

		_taskTrees.add(TASK_NAME_TREE, new TreeSet<Task>(new NameComparator()));
		_taskTrees.add(TASK_START_TIME_TREE, new TreeSet<Task>(new StartTimeComparator()));
		_taskTrees.add(TASK_END_TIME_TREE, new TreeSet<Task>(new EndTimeComparator()));
		_taskTrees.add(TASK_FLAG_TREE, new TreeSet<Task>(new FlagComparator()));
		_taskTrees.add(TASK_PRIORITY_TREE, new TreeSet<Task>(new PriorityComparator()));
		_taskTrees.add(TASK_ID_TREE, new TreeSet<Task>(new IdComparator()));

		fromValueHandler = Task.getVirtualTask();

		// Fill TaskTree from file storage
		boolean isValidFile = iniTaskFileHandler(taskFilePath);
		pullFromStorage();
		return isValidFile;
	}

	/**
	 * Construct and return a new instance of {@code TaskTree}. If the taskTree
	 * has already been constructed, the previous instance is replaced.
	 *
	 * @return a new instance of {@code TaskTree}. This new {@code TaskTree}
	 *         will replace the previous instance of the TaskTree.
	 */
	public static TaskTree newTaskTree(String taskFilePath) {
		init(taskFilePath);
		return getTaskTree();
	}

	/**
	 * Return the original instance of {@code TaskTree}
	 *
	 * @return the original instance of {@code TaskTree}
	 */
	public static TaskTree getTaskTree() {
		return _taskTree;
	}

	// TaskTree Task operation: Add and Remove
	/**
	 * Adds the specified {@code Task} object to this {@code TaskTree}
	 *
	 * @param task
	 *            to be added to this {@code TaskTree}
	 * @return true if this {@code TaskTree} did not already contain the
	 *         specified {@code Task} object
	 */
	public boolean add(Task task) {

		if (task == null) {
			throw new NullPointerException();
		}

		boolean isAddedToData = true;
		boolean isAddedToFile = true;

		for (TreeSet<Task> tree : _taskTrees) {
			isAddedToData &= tree.add(task);
			assert isAddedToData;
		}

		if (isAddedToData) {
			increaseTaskListSize();
			isAddedToFile &= pushAddToStorage(task);
		}

		return isAddedToData && isAddedToFile;
	}

	/**
	 * Removes the specified {@code Task} object to this {@code TaskTree}
	 *
	 * @param task
	 *            to be removed from this {@code TaskTree}
	 * @return true if this {@code TaskTree} contained the specified
	 *         {@code Task} object
	 */
	public boolean remove(Task task) {

		if (task == null) {
			throw new NullPointerException();
		}

		boolean isRemovedFromData = true;
		boolean isRemovedFromFile = true;

		for (TreeSet<Task> tree : _taskTrees) {
			isRemovedFromData &= tree.remove(task);
			assert isRemovedFromData;
		}
		if (isRemovedFromData) {
			decreaseTaskListSize();
			isRemovedFromFile &= pushRemoveToStorage(task);
		}
		return isRemovedFromData && isRemovedFromFile;
	}

	// TaskTree Task operation: Update
	/**
	 * Update a {@code Task} object from this {@code TaskTree} with the given
	 * new name
	 *
	 * @param task
	 *            to be modified from this {@code TaskTree}
	 * @param newValue
	 *            to update this task
	 * @return true if this {@code TaskTree} contained the task and can be
	 *         modified
	 */
	public boolean updateName(Task task, String newValue) {
		TYPE taskAttributeType = TYPE.NAME;
		boolean isAdded, isRemoved, isReplaced;
		isReplaced = isAdded = isRemoved = false;

		isRemoved = removeFromAttributeTree(task, taskAttributeType);

		if (isRemoved) {
			task.setName(newValue);
			isAdded = addToAttributeTree(task, taskAttributeType);
		}

		isReplaced = isRemoved & isAdded;

		if (isReplaced) {
			pushUpdateToStorage(task);
		}

		return isReplaced;
	}

	/**
	 * Update a {@code Task} object from this {@code TaskTree} with the given
	 * new description
	 *
	 * @param task
	 *            to be modified from this {@code TaskTree}
	 * @param newValue
	 *            to update this task
	 * @return true if this {@code TaskTree} contained the task and can be
	 *         modified
	 * @deprecated Description field is deprecated.
	 */
	public void updateDescription(Task task, String newValue) {
		task.setDescription(newValue);
		pushUpdateToStorage(task);
	}

	/**
	 * Update a {@code Task} object from this {@code TaskTree} with the given
	 * new start time
	 *
	 * @param task
	 *            to be modified from this {@code TaskTree}
	 * @param newValue
	 *            to update this task
	 * @return true if this {@code TaskTree} contained the task and can be
	 *         modified
	 */
	public boolean updateStartTime(Task task, long newValue) {
		TYPE taskAttributeType = TYPE.START_TIME;
		boolean isAdded, isRemoved, isReplaced;
		isReplaced = isAdded = isRemoved = false;

		isRemoved = removeFromAttributeTree(task, taskAttributeType);

		if (isRemoved) {
			task.setStartTime(newValue);
			isAdded = addToAttributeTree(task, taskAttributeType);
		}

		isReplaced = isRemoved & isAdded;

		if (isReplaced) {
			pushUpdateToStorage(task);
		}

		return isReplaced;
	}

	/**
	 * Update a {@code Task} object from this {@code TaskTree} with the given
	 * new end time
	 *
	 * @param task
	 *            to be modified from this {@code TaskTree}
	 * @param newValue
	 *            to update this task
	 * @return true if this {@code TaskTree} contained the task and can be
	 *         modified
	 */
	public boolean updateEndTime(Task task, long newValue) {
		TYPE taskAttributeType = TYPE.END_TIME;
		boolean isAdded, isRemoved, isReplaced;
		isReplaced = isAdded = isRemoved = false;

		isRemoved = removeFromAttributeTree(task, taskAttributeType);

		if (isRemoved) {
			task.setEndTime(newValue);
			isAdded = addToAttributeTree(task, taskAttributeType);
		}

		isReplaced = isRemoved & isAdded;

		if (isReplaced) {
			pushUpdateToStorage(task);
		}

		return isReplaced;
	}

	/**
	 * Update a {@code Task} object from this {@code TaskTree} with the given
	 * new flag
	 *
	 * @param task
	 *            to be modified from this {@code TaskTree}
	 * @param newValue
	 *            to update this task
	 * @return true if this {@code TaskTree} contained the task and can be
	 *         modified
	 */
	public boolean updateFlag(Task task, FLAG_TYPE newValue) {
		TYPE taskAttributeType = TYPE.FLAG;
		boolean isAdded, isRemoved, isReplaced;
		isReplaced = isAdded = isRemoved = false;

		isRemoved = removeFromAttributeTree(task, taskAttributeType);

		if (isRemoved) {
			task.setFlag(newValue);
			isAdded = addToAttributeTree(task, taskAttributeType);
		}

		isReplaced = isRemoved & isAdded;

		if (isReplaced) {
			pushUpdateToStorage(task);
		}

		return isReplaced;
	}

	/**
	 * Update a {@code Task} object from this {@code TaskTree} with the given
	 * new priority
	 *
	 * @param task
	 *            to be modified from this {@code TaskTree}
	 * @param newValue
	 *            to update this task
	 * @return true if this {@code TaskTree} contained the task and can be
	 *         modified
	 */
	public boolean updatePriority(Task task, PRIORITY_TYPE newValue) {
		TYPE taskAttributeType = TYPE.PRIORITY;
		boolean isAdded, isRemoved, isReplaced;
		isReplaced = isAdded = isRemoved = false;

		isRemoved = removeFromAttributeTree(task, taskAttributeType);

		if (isRemoved) {
			task.setPriority(newValue);
			isAdded = addToAttributeTree(task, taskAttributeType);
		}

		isReplaced = isRemoved & isAdded;

		if (isReplaced) {
			pushUpdateToStorage(task);
		}

		return isReplaced;
	}

	private boolean removeFromAttributeTree(Task oldTask, TYPE taskAttributeType) {
		int treeType = taskAttributeType.getValue();

		boolean isRemoved = false;
		isRemoved = _taskTrees.get(treeType).remove(oldTask);
		return isRemoved;
	}

	private boolean addToAttributeTree(Task newTask, TYPE taskAttributeType) {
		int treeType = taskAttributeType.getValue();

		boolean isAdded = false;
		isAdded = _taskTrees.get(treeType).add(newTask);
		return isAdded;
	}

	// TaskTree Task operation: Search and query
	/**
	 * Returns a view of the portion of this {@code TaskTree} whose {@code Task}
	 * objects contain the {@code searchTerm}. The returned {@code List} is
	 * backed by this {@code TaskTree}, so changes in the returned {@code List}
	 * are reflected in this {@code TaskTree}, and vice-versa.
	 *
	 * @param searchTerm
	 *            the sequence to search for
	 * @return a view of the portion of this {@code TaskTree} whose {@code Task}
	 *         object contain the {@code searchTerm}
	 * @throws IllegalArgumentException
	 *             if search term is empty
	 */
	public List<Task> searchName(String searchTerm) {
		ArrayList<Task> resultList = new ArrayList<Task>(_taskTreeSize);

		if (searchTerm == null) {
			throw new IllegalArgumentException(MSG_ERR_SEARCH_TERM_EMPTY);
		}

		boolean isCaseInsensitive = checkLowercase(searchTerm);
		String checkNameString;
		String checkString;

		for (Task task : _taskTrees.get(TASK_NAME_TREE)) {

			checkNameString = task.getName();
			checkString = checkNameString;

			if (isCaseInsensitive) {
				checkString = checkString.toLowerCase();
			}

			if (checkString.contains(searchTerm)) {
				resultList.add(task);
			}
		}
		return resultList;
	}

	private boolean checkLowercase(String text) {
		int textLength = text.length();
		char charInText;

		for (int i = 0; i < textLength; i++) {
			charInText = text.charAt(i);
			if (charInText >= 'A' && charInText <= 'Z') {
				return false;
			}
		}
		return true;
	}

	/**
	 * Returns a view of the portion of this {@code TaskTree} whose {@code Task}
	 * objects range from {@code fromStartTime}, inclusive, to
	 * {@code toStartTime}, inclusive. (If {@code fromStartTime} and
	 * {@code toStartTime} are equal, the returned {@code List} contains
	 * {@code Task} object that matches {@code fromEndTime}.) The returned
	 * {@code List} is backed by this {@code TaskTree}, so changes in the
	 * returned {@code List} are reflected in this {@code TaskTree}, and
	 * vice-versa.
	 *
	 * @param fromStartTime
	 *            low endpoint (inclusive) of the returned list
	 * @param toStartTime
	 *            high endpoint (inclusive) of the returned list
	 * @return a view of the portion of this {@code TaskTree} whose {@code Task}
	 *         objects range from {@code fromStartTime}, inclusive, to
	 *         {@code toStartTime}, inclusive
	 */
	public List<Task> queryStartTime(long fromStartTime, long toStartTime) {
		return query(TYPE.START_TIME, fromStartTime, toStartTime);
	}

	/**
	 * Returns a view of the portion of this {@code TaskTree} whose {@code Task}
	 * objects range from {@code fromEndTime}, inclusive, to {@code toEnd}Time,
	 * inclusive. (If {@code fromEndTime} and {@code toEndTime} are equal, the
	 * returned {@code List} contains {@code Task} object that matches
	 * {@code fromEndTime} only.) The returned {@code List} is backed by this
	 * {@code TaskTree}, so changes in the returned {@code List} are reflected
	 * in this {@code TaskTree}, and vice-versa.
	 *
	 * @param fromEndTime
	 *            low endpoint (inclusive) of the returned list
	 * @param toEndTime
	 *            high endpoint (inclusive) of the returned list
	 * @return a view of the portion of this {@code TaskTree} whose {@code Task}
	 *         objects range from {@code fromEndTime}, inclusive, to
	 *         {@code toEndTime}, inclusive
	 */
	public List<Task> queryEndTime(long fromEndTime, long toEndTime) {
		return query(TYPE.END_TIME, fromEndTime, toEndTime);
	}

	/**
	 * Returns a view of the portion of this {@code TaskTree} whose {@code Task}
	 * objects range from {@code fromFlag}, inclusive, to {@code toFlag},
	 * inclusive. (If {@code fromFlag} and {@code toFlag} are equal, the
	 * returned {@code List} contains {@code Task} object that matches
	 * {@code fromFlag} only.) The returned {@code List} is backed by this
	 * {@code TaskTree}, so changes in the returned {@code List} are reflected
	 * in this {@code TaskTree}, and vice-versa.
	 *
	 * @param fromFlag
	 *            low endpoint (inclusive) of the returned list
	 * @param toFlag
	 *            high endpoint (inclusive) of the returned list
	 * @return a view of the portion of this {@code TaskTree} whose {@code Task}
	 *         objects range from {@code fromFlag}, inclusive, to {@code toFlag}
	 *         , inclusive
	 */
	public List<Task> queryFlag(FLAG_TYPE fromFlag, FLAG_TYPE toFlag) {

		int fromValue = fromFlag.getValue();
		int toValue = toFlag.getValue();

		return query(TYPE.FLAG, fromValue, toValue);
	}

	/**
	 * Returns a view of the portion of this {@code TaskTree} whose {@code Task}
	 * objects range from {@code fromPriority}, inclusive, to {@code toPriority}
	 * , inclusive. (If {@code fromPriority} and {@code toPriority} are equal,
	 * the returned {@code List} contains {@code Task} object that matches
	 * {@code fromPriority} only.) The returned {@code List} is backed by this
	 * {@code TaskTree}, so changes in the returned {@code List} are reflected
	 * in this {@code TaskTree}, and vice-versa.
	 *
	 * @param fromPriority
	 *            low endpoint (inclusive) of the returned list
	 * @param toPriority
	 *            high endpoint (inclusive) of the returned list
	 * @return a view of the portion of this {@code TaskTree} whose {@code Task}
	 *         objects range from {@code fromPriority}, inclusive, to
	 *         {@code toPriority}, inclusive
	 */
	public List<Task> queryPriority(PRIORITY_TYPE fromPriority, PRIORITY_TYPE toPriority) {

		int fromValue = fromPriority.getValue();
		int toValue = toPriority.getValue();

		return query(TYPE.PRIORITY, fromValue, toValue);
	}

	/**
	 * Returns a view of the portion of this {@code TaskTree} whose {@code Task}
	 * objects range from {@code fromValueL}, inclusive, to {@code toValueL},
	 * inclusive given the specified {@code taskAttributeType}. (If
	 * {@code fromValueL} and {@code toValueL} are equal, the returned
	 * {@code List} contains {@code Task} object that matches {@code fromValueL}
	 * only.) The returned {@code List} is backed by this {@code TaskTree}, so
	 * changes in the returned {@code List} are reflected in this
	 * {@code TaskTree}, and vice-versa. To query flag and priority, please use
	 * its respective query method.
	 *
	 * @param taskAttributeType
	 *            the attribute type to be query with.
	 * @param fromValueL
	 *            low endpoint (inclusive) of the returned list
	 * @param toValueL
	 *            high endpoint (inclusive) of the returned list
	 * @return a view of the portion of this {@code TaskTree} whose {@code Task}
	 *         objects range from {@code fromValueL}, inclusive, to
	 *         {@code toValueL}, inclusive
	 */
	public List<Task> query(TYPE taskAttributeType, long fromValueL, long toValueL) {

		int treeType = taskAttributeType.getValue();

		TreeSet<Task> taskTree = _taskTrees.get(treeType);
		ArrayList<Task> emptyList = new ArrayList<Task>();
		boolean isToInclusive;
		Task toValueHdlBuffer;

		if (toValueL < fromValueL) {
			return emptyList;
		} else {
			toValueHdlBuffer = Task.getVirtualTask();
			if (toValueL == fromValueL) {
				isToInclusive = false;
			} else {
				isToInclusive = true;
			}
			switch (taskAttributeType) {
			case END_TIME:
				fromValueHandler.setEndTime(fromValueL);
				toValueHdlBuffer.setEndTime(toValueL);
				break;
			case START_TIME:
				fromValueHandler.setStartTime(fromValueL);
				toValueHdlBuffer.setStartTime(toValueL);
				break;
			case PRIORITY:
				fromValueHandler.setPriority(PRIORITY_TYPE.get((int) fromValueL));
				toValueHdlBuffer.setPriority(PRIORITY_TYPE.get((int) toValueL));
				break;
			case FLAG:
				fromValueHandler.setFlag(FLAG_TYPE.get((int) fromValueL));
				toValueHdlBuffer.setFlag(FLAG_TYPE.get((int) toValueL));
				break;
			case ID:
				fromValueHandler.setId((int) fromValueL);
				toValueHdlBuffer.setId((int) toValueL);
				break;
			default:
				return emptyList;
			}
			return new ArrayList<Task>(taskTree.subSet(fromValueHandler, true, toValueHdlBuffer, isToInclusive));
		}
	}

	/**
	 * Returns a task from this {@code TaskTree} via its id. The returned
	 * {@code Task} is backed by this {@code TaskTree}, so changes in the
	 * returned {@code Task} are reflected in this {@code TaskTree}, and
	 * vice-versa.
	 *
	 * @param id
	 *            to get
	 * @return a task from this {@code TaskTree} via its ID if found; otherwise
	 *         null.
	 *
	 * @see taskCollections.Task
	 *
	 */
	public Task getTask(int id) {

		TreeSet<Task> idTree = _taskTrees.get(TASK_ID_TREE);

		for (Task task : idTree) {
			if (task.getId() == id)
				return task;
		}
		return null;
	}

	/**
	 * Returns a view of the portion of this {@code TaskTree} whose {@code Task}
	 * objects matches the {@code flagSearch}. The returned {@code List} is
	 * backed by this {@code TaskTree}, so changes in the returned {@code List}
	 * are reflected in this {@code TaskTree}, and vice-versa.
	 *
	 * @param type
	 *            to search for
	 * @return a view of the portion of this {@code TaskTree} whose {@code Task}
	 *         objects match the {@code flagSearch}
	 * @see taskCollections.Task
	 *
	 */
	public List<Task> searchFlag(FLAG_TYPE type) {
		int flagValue = type.getValue();

		return query(TYPE.FLAG, flagValue, flagValue);
	}

	/**
	 * Returns a view of the portion of this {@code TaskTree} whose {@code Task}
	 * objects matches the {@code prioritySearch}. The returned {@code List} is
	 * backed by this {@code TaskTree}, so changes in the returned {@code List}
	 * are reflected in this {@code TaskTree}, and vice-versa.
	 *
	 * @param type
	 *            to search for
	 * @return a view of the portion of this {@code TaskTree} whose {@code Task}
	 *         objects match the {@code prioritySearch}
	 * @see taskCollections.Task
	 *
	 */
	public List<Task> searchPriority(PRIORITY_TYPE type) {
		int priorityValue = type.getValue();

		return query(TYPE.PRIORITY, priorityValue, priorityValue);
	}

	// TaskTree operation: getList
	/**
	 * Returns a view of this {@code TaskTree} whose {@code Task} objects are
	 * sorted according to order it is created. The returned {@code List} is
	 * backed by this {@code TaskTree}, so changes in the returned {@code List}
	 * are reflected in this {@code TaskTree}, and vice-versa.
	 *
	 * @return a view of this {@code TaskTree}.
	 */
	public List<Task> getList() {
		int treeType = Attributes.TYPE.ID.getValue();
		return getSortedList(_taskTrees.get(treeType));
	}

	/**
	 * Returns a view of this {@code TaskTree} whose {@code Task} objects are
	 * sorted according to its specified attribute type. The returned
	 * {@code List} is backed by this {@code TaskTree}, so changes in the
	 * returned {@code List} are reflected in this {@code TaskTree}, and
	 * vice-versa.
	 *
	 * @param taskAttributeType
	 *            the attribute type to be sorted with.
	 * @return a view of this {@code TaskTree} whose {@code Task} objects are
	 *         sorted according to its specified attribute type.
	 * @see taskCollections.Attributes
	 */
	public List<Task> getSortedList(TYPE taskAttributeType) {
		int taskAttributeIndex = taskAttributeType.getValue();
		return getSortedList(_taskTrees.get(taskAttributeIndex));
	}

	private List<Task> getSortedList(TreeSet<Task> taskTree) {
		ArrayList<Task> resultList = new ArrayList<Task>(taskTree);
		return resultList;
	}

	// TaskTree operation: getString
	/**
	 * Returns a string representation of this {@code TaskTree}. The string
	 * representation consists of a list of the {@code TaskTree}'s {@code Task}
	 * objects in the order they are returned by its iterator, enclosed in
	 * square brackets ("[]"). Adjacent {@code Task} objects are separated by
	 * the characters ", " (comma and space). {@code Task} objects are converted
	 * to strings as by String.toString(Object).
	 *
	 * @return a string representation of this task tree in a list.
	 *
	 */
	public String getString() {
		return getString(Attributes.TYPE.ID);
	}

	/**
	 * Return a string representation of this {@code TaskTree} sorted in order
	 * of the specified {@code taskAttributeType}. The string representation
	 * consists of a list of the {@code TaskTree}'s {@code Task} objects in the
	 * order they are returned by its iterator, enclosed in square brackets
	 * ("[]"). Adjacent {@code Task} objects are separated by the characters
	 * ", " (comma and space). {@code Task} objects are converted to strings as
	 * by String.toString(Object).
	 *
	 * @param taskAttributeType
	 *            the attribute type to be printed.
	 * @return a string representation of this task tree in a list.
	 */
	public String getString(TYPE taskAttributeType) {

		ArrayList<Task> resultList = new ArrayList<Task>(getSortedList(taskAttributeType));
		int listSize = resultList.size();
		int lastIndex = listSize - 1;

		String buffer = TO_STRING_OPEN;
		for (int i = 0; i < lastIndex; i++) {
			buffer += resultList.get(i) + TO_STRING_DELIMETER;
		}
		buffer += resultList.get(lastIndex) + TO_STRING_CLOSE;

		return buffer;
	}

	// TaskTree operation: size related
	/**
	 * Return total number of task in this tree
	 *
	 * @return number of task in this tree
	 */
	public int size() {
		return _taskTreeSize;
	}

	public int getOverdueCount() {

		long startTime = Task.DATE_START;
		long endTime = System.currentTimeMillis();
		ArrayList<Task> overdueTasks = new ArrayList<Task>(queryEndTime(startTime, endTime));

		int overdueCount = 0;
		for (Task task: overdueTasks) {
			if (task.getFlag() == FLAG_TYPE.NULL) {
				overdueCount++;
			}
		}
		return overdueCount;
	}

	public int getStartTimeRangeCount(long startTime, long endTime) {
		return queryEndTime(startTime, endTime).size();
	}

	public int getEndTimeRangeCount(long startTime, long endTime) {
		return queryEndTime(startTime, endTime).size();
	}

	public int getFlagCount(FLAG_TYPE flagType) {
		return searchFlag(flagType).size();
	}

	public int getPriorityCount(PRIORITY_TYPE priortyType) {
		return searchPriority(priortyType).size();
	}

	private void increaseTaskListSize() {
		_taskTreeSize += 1;
	}

	private void decreaseTaskListSize() {
		_taskTreeSize -= 1;
	}

	// Storage related methods

	// TaskTree operation: File Storage related
	/**
	 * Push a new task to storage file.
	 *
	 * @throws Exception
	 */
	private boolean pushAddToStorage(Task task) {
		boolean isPushSuccessful = true;

		isPushSuccessful &= _fileHandler.add(task);

		return isPushSuccessful;
	}

	/**
	 * Remove a task from the storage
	 *
	 * @throws Exception
	 */
	private boolean pushRemoveToStorage(Task task) {
		int taskId = task.getId();
		boolean isPullSuccessful = true;

		isPullSuccessful &= _fileHandler.delete(taskId);

		return isPullSuccessful;
	}

	/**
	 * Update a new task to storage file.
	 *
	 * @throws Exception
	 */
	private boolean pushUpdateToStorage(Task task) {
		return pushUpdateToStorage(task, task);
	}

	/**
	 * Update a new task to storage file.
	 *
	 * @throws Exception
	 */
	private boolean pushUpdateToStorage(Task oldTask, Task newTask) {
		int oldId = oldTask.getId();
		int newId = newTask.getId();
		boolean isPushSuccessful = true;

		if (oldId == newId) {
			isPushSuccessful &= _fileHandler.update(newTask);
		} else {
			isPushSuccessful &= _fileHandler.delete(oldId);
			isPushSuccessful &= _fileHandler.add(newTask);
		}

		return isPushSuccessful;
	}

	/**
	 * To retrieve task list the Task file. This method is called upon the
	 * starting of this program.
	 */
	private static void pullFromStorage() {
		ArrayList<Task> taskList;
		taskList = _fileHandler.retrieveTaskList();

		for (TreeSet<Task> tree : _taskTrees) {
			tree.addAll(taskList);
		}
		_taskTreeSize = taskList.size();
	}

	/**
	 * This method will be called to construct the taskFileHandler for file
	 * storage
	 *
	 * @param taskFilePath
	 *            directed to the storage XML file for tasks.
	 */
	private static boolean iniTaskFileHandler(String taskFilePath) {

		_fileHandler = new TaskFileHandler();
		return _fileHandler.loadTaskFile(taskFilePath);
	}
}
```
###### taskCollections\test\TaskTest.java
``` java
package taskCollections.test;
import org.junit.Test;

import taskCollections.Task;
import taskCollections.Task.FLAG_TYPE;
import taskCollections.Task.PRIORITY_TYPE;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import java.util.Date;

/**
 * Provide a JUnit test for the {@code Task.java}.
 *
 * @author amoshydra
 */
public class TaskTest {

	@SuppressWarnings("unused")
	private static final int MINUTE = 60;
	private static final int HOUR = 3600;

	// Initializing task attributes
	private String taskName 			= "Buy Milk";
	private String taskNameLowCase		= "buy milk";
	private String taskNameDiff			= "Buy Yogurt";

	private String description 			= "brand: Meji, Vol: 5L";

	private Date nowTime 	= new Date();
	private long startTime	= nowTime.getTime() % 1000;
	private long endTime	= startTime + (2 * HOUR);

	private FLAG_TYPE flag = Task.FLAG_TYPE.NULL;
	private PRIORITY_TYPE priority = Task.PRIORITY_TYPE.NORMAL;

	// Setting up different task conditions
	private static final int TASK_ORIGINAL = 0;
	private static final int TASK_SAME_TASK = 1;
	private static final int TASK_LOW_CASE = 2;
	private static final int TASK_IS_DONE = 3;
	private static final int TASK_DIFF_TIME = 4;
	private static final int TASK_DIFF_NAME = 5;
	private static final int TASK_DIFF_PRIORITY = 6;
	@SuppressWarnings("unused")
	private static final int TASK_ARRAY_SIZE = 7;

	@SuppressWarnings("deprecation")
	Task[] tasks = {
			new Task(taskName, description, startTime, endTime, flag, priority),
			new Task(taskName, description, startTime, endTime, flag, priority),
			new Task(taskNameLowCase, description, startTime, endTime, flag, priority),
			new Task(taskName, description, startTime, endTime, Task.FLAG_TYPE.DONE, priority),
			new Task(taskName, description, startTime, startTime, flag, priority),
			new Task(taskNameDiff, description, startTime, endTime, flag, priority),
			new Task(taskName, description, startTime, endTime, flag, Task.PRIORITY_TYPE.HIGH)
			};

	@Test
	public void testEquals() {

		// Setting up test cases
		boolean testEqual, testDiffCase, testDiffName, testDiffTime, testDiffFlag, testDiffPriority;

		testEqual = 	tasks[TASK_ORIGINAL].equals(tasks[TASK_SAME_TASK]);
		testDiffCase =	tasks[TASK_ORIGINAL].equals(tasks[TASK_LOW_CASE]);
		testDiffName =	tasks[TASK_ORIGINAL].equals(tasks[TASK_DIFF_NAME]);
		testDiffTime =	tasks[TASK_ORIGINAL].equals(tasks[TASK_DIFF_TIME]);
		testDiffFlag =	tasks[TASK_ORIGINAL].equals(tasks[TASK_IS_DONE]);
		testDiffPriority =	tasks[TASK_ORIGINAL].equals(tasks[TASK_DIFF_PRIORITY]);

		// Evaluate test cases
		assertTrue(testEqual);
		assertFalse(testDiffCase);
		assertFalse(testDiffName);
		assertFalse(testDiffTime);
		assertFalse(testDiffFlag);
		assertFalse(testDiffPriority);
	}

	@Test
	public void testCompares() {

		// Setting up test cases
		int testSameTask, testDiffCase, testDiffName, testDiffTime, testDiffFlag, testDiffPriority;

		testSameTask = tasks[TASK_ORIGINAL].compareTo(tasks[TASK_SAME_TASK]);
		testDiffCase = tasks[TASK_ORIGINAL].compareNameTo(tasks[TASK_LOW_CASE]);
		testDiffName = tasks[TASK_ORIGINAL].compareNameTo(tasks[TASK_DIFF_NAME]);
		testDiffTime = tasks[TASK_ORIGINAL].compareEndTimeTo(tasks[TASK_DIFF_TIME]);
		testDiffFlag = tasks[TASK_ORIGINAL].compareFlagTo(tasks[TASK_IS_DONE]);
		testDiffPriority = tasks[TASK_ORIGINAL].comparePriorityTo(tasks[TASK_DIFF_PRIORITY]);

		// Evaluate test cases
		assertTrue(testSameTask < 0);		// "TASK_ORIGINAL is created earlier than TASK_SAME_TASK"
		assertTrue(testDiffCase < 0);		// "Buy Milk" is smaller than "buy milk"
		assertTrue(testDiffName < 0);		// "Buy Milk" is greater than "Buy Yogurt"
		assertTrue(testDiffTime > 0);		// "2 * HOUR" is greater than "0"
		assertTrue(testDiffFlag < 0);		// "IS_NULL" is smaller than "IS_DONE"
		assertTrue(testDiffPriority > 0);	// "NORMAL" is greater than "VERY_HIGH"
	}
}
```
###### taskCollections\test\TaskTreeTest.java
``` java
package taskCollections.test;

import taskCollections.Task;
import taskCollections.Task.FLAG_TYPE;
import taskCollections.Task.PRIORITY_TYPE;
import taskCollections.TaskTree;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.nio.file.DirectoryNotEmptyException;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import org.junit.Test;

/**
 * Provide a JUnit test for the {@code TaskTree.java}.
 *
 * @author amoshydra
 */
public class TaskTreeTest {
	private static TaskTree _taskTree;
	private static final String testTaskFilePath = "test_taskTreeJUnitFile.xml";
	private static final int FIRST_ELEMENT = 0;
	private static final int LAST_ELEMENT = 4;
	private static final int NUM_OF_ITEMS = 5;
	private static final int FIVE_SECONDS = 5000;
	private String[] names = {
			"Buy mushroom",
			"Buy milk",
			"Buy hotdog",
			"Do homework",
			"Learn swimming" };
	private String[] descriptions = {
			"",
			"brand, Meji, 1 litre",
			"extra mustard",
			"",
			"" };
	private long[] startTimes = { 0L, 1L, 2L, 3L, 4L };
	private long[] endTimes = {
			0L, // floating task
			1441119600000L, // 01 Sep 2015 15:00:00
			1442734205000L, // 20 Sep 2015 07:30:05
			1443112320000L, // 24 Sep 2015 16:32:00
			1444059228000L // 05 Oct 2015 15:33:48
			};
	private FLAG_TYPE[] flags = {
			Task.FLAG_TYPE.DONE,
			Task.FLAG_TYPE.NULL,
			Task.FLAG_TYPE.NULL,
			Task.FLAG_TYPE.NULL,
			Task.FLAG_TYPE.NULL };
	private PRIORITY_TYPE[] priorities = {
			Task.PRIORITY_TYPE.NORMAL,
			Task.PRIORITY_TYPE.HIGH,
			Task.PRIORITY_TYPE.NORMAL,
			Task.PRIORITY_TYPE.HIGH,
			Task.PRIORITY_TYPE.NORMAL };

	/**
	 * Initialize a new instance of {@code TaskTree}
	 */
	private void initialiseTaskTree() {
		File testFile = new File(testTaskFilePath);
		if (testFile.exists()) {
			deleteFile(testTaskFilePath);
		}

		createTaskFile(testTaskFilePath);

		_taskTree = TaskTree.getTaskTree();
		_taskTree = null;
		_taskTree = TaskTree.newTaskTree(testTaskFilePath);
	}

	/**
	 * Destroy the current instance of {@code TaskTree}
	 */
	private void deinitialiseTaskTree() {
		_taskTree = null;
		deleteFile(testTaskFilePath);
	}

	/**
	 * Delete a file from the system with the given file path
	 *
	 * @param filePathString
	 *            file path to delete
	 */
	private void deleteFile(String filePathString) {
		// TODO let some other class to create this file for me.
		Path filePath = Paths.get(filePathString);

		try {
			Files.delete(filePath);
		} catch (NoSuchFileException x) {
			//TODO replace error messages
			System.err.format("%s: no such" + " file or directory%n", filePath);
		} catch (DirectoryNotEmptyException x) {
			System.err.format("%s not empty%n", filePath);
		} catch (IOException x) {
			// File permission problems are caught here.
			System.err.println(x);
		}
	}

	private String generateCheckString(ArrayList<Task> checkList) {
		// TODO Replace magic string
		String checkString = "[";
		for (Task task : checkList) {
			checkString += task + ",";
		}
		checkString = checkString.substring(0, checkString.length() - 1);
		checkString += "]";

		return checkString;
	}

	private Task generateSampleTask(int index) {
		@SuppressWarnings("deprecation")
		Task sampleTask = new Task(names[index],
								   descriptions[index],
								   startTimes[index],
								   endTimes[index],
								   flags[index],
								   priorities[index]);
		return sampleTask;
	}

	private void populateSampleTasks() {
		for (int i = 0; i < NUM_OF_ITEMS; i++) {
			Task sampleTask = generateSampleTask(i);
			_taskTree.add(sampleTask);
		}
	}

	private void createTaskFile(String fileName) {
		PrintWriter pw;
		try {
			pw = new PrintWriter(fileName, "UTF-8");
			pw.println("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>");
			pw.println("<tasklist>");
			pw.println("</tasklist>");
			pw.close();
			return;
		} catch (FileNotFoundException e) {
			System.err.println("File Not Found");
			return;
		} catch (UnsupportedEncodingException e) {
			System.err.println("Unsupported Encoding");
			return;
		}
	}

	/*
	 * Testing methods
	 * 1. add method will increase the size of task tree
	 * 2. make sure taskTree initialisation will always return an empty taskTree.
	 *
	 * Condition
	 * 1. Normal
	 */
	@Test
	public void testInitialiseTaskTree() {
		createTaskFile(testTaskFilePath);
		_taskTree = TaskTree.newTaskTree(testTaskFilePath);
		populateSampleTasks();
		ArrayList<Task> initialList = new ArrayList<Task>(_taskTree.getList());
		assertFalse(initialList.isEmpty());

		initialiseTaskTree();
		ArrayList<Task> initialisedList = new ArrayList<Task>(_taskTree.getList());
		assertTrue(initialisedList.isEmpty());
		deinitialiseTaskTree();
	}

	/*
	 * Testing methods
	 * 1. add
	 * 2. getString
	 *
	 * Condition
	 * 1. Normal
	 */
	@Test
	public void testAddElementsToTree () {
		initialiseTaskTree();

		ArrayList<Task> checkList = new ArrayList<Task>(NUM_OF_ITEMS);

		Task temp;
		boolean isAllAddedToTaskTree = true;
		boolean isAllAddedToArrayList = true;
		for (int i = 0; i < NUM_OF_ITEMS; i++) {
			temp = generateSampleTask(i);

			// Add tasks to TaskTree via its add command
			isAllAddedToTaskTree &= _taskTree.add(temp);

			// Add tasks to an ArrayList
			isAllAddedToArrayList &= checkList.add(temp);
		}

		assertTrue(isAllAddedToTaskTree);
		assertTrue(isAllAddedToArrayList);

		String checkString = generateCheckString(checkList);
		String resultString = _taskTree.getString();
		assertEquals(resultString, checkString);

		deinitialiseTaskTree();
	}

	/*
	 * Testing methods
	 * 1. add
	 * 2. size
	 *
	 * Condition
	 * 1. Adding an existing task object
	 */
	@Test
	public void testAddIdenticalElementsToTree () {
		initialiseTaskTree();

		int firstTaskIndex = 1;
		int secondTaskIndex = 2;
		int numberOfSampleTask = 2;

		Task sampleTask1 = generateSampleTask(firstTaskIndex);
		Task sampleTask2 = generateSampleTask(secondTaskIndex);

		boolean isAllAddedToTaskTree = true;

		// Add the first task to TaskTree via its add command
		isAllAddedToTaskTree &= _taskTree.add(sampleTask1);
		assertTrue(isAllAddedToTaskTree);
		assertEquals(_taskTree.size(), firstTaskIndex);

		// Add the second task to TaskTree via its add command
		isAllAddedToTaskTree &= _taskTree.add(sampleTask2);
		assertTrue(isAllAddedToTaskTree);
		assertEquals(_taskTree.size(), secondTaskIndex);

		// Add the first task again to TaskTree via its add command
		isAllAddedToTaskTree &= _taskTree.add(sampleTask1);
		assertFalse(isAllAddedToTaskTree);
		assertEquals(_taskTree.size(), numberOfSampleTask);

		deinitialiseTaskTree();
	}

	/*
	 * Testing methods
	 * 1. add
	 * 2. size
	 *
	 * Condition
	 * 1. Adding an existing task object
	 */
	@Test(expected=NullPointerException.class)
	public void testAddNullElementsToTree () {
		initialiseTaskTree();

		Task sampleTask1 = null;

		// Add the first task to TaskTree via its add command
		_taskTree.add(sampleTask1);

		deinitialiseTaskTree();
	}


	@Test
	public void testRemoveElementsFromTree() {
		initialiseTaskTree();

		ArrayList<Task> checkList = new ArrayList<Task>(NUM_OF_ITEMS);

		Task temp;
		for (int i = 0; i < NUM_OF_ITEMS; i++) {
			temp = generateSampleTask(i);
			_taskTree.add(temp);
			checkList.add(temp);
		}

		int listSize = _taskTree.size();
		ArrayList<Task> returnList;
		String searchTerm;

		// Get original list
		searchTerm = "Buy";
		returnList = new ArrayList<Task>(_taskTree.searchName(searchTerm));
		assertEquals(_taskTree.size(), listSize);

		// Remove last element
		_taskTree.remove(returnList.get(returnList.size() - 1));
		searchTerm = "Buy";
		returnList = new ArrayList<Task>(_taskTree.searchName(searchTerm));
		assertEquals(_taskTree.size(), listSize -= 1);

		// Remove second element
		_taskTree.remove(returnList.get(FIRST_ELEMENT + 1));
		searchTerm = "Buy";
		returnList = new ArrayList<Task>(_taskTree.searchName(searchTerm));
		assertEquals(_taskTree.size(), listSize -= 1);

		// Remove last element
		_taskTree.remove(returnList.get(FIRST_ELEMENT));
		searchTerm = "Buy";
		returnList = new ArrayList<Task>(_taskTree.searchName(searchTerm));
		assertEquals(_taskTree.size(), listSize -= 1);

		// Remove non-existing element
		@SuppressWarnings("deprecation")
		Task extraTask = new Task("Name", "Description", 0, 0, Task.FLAG_TYPE.NULL, Task.PRIORITY_TYPE.HIGH);
		assertFalse(_taskTree.remove(extraTask));
		assertEquals(_taskTree.size(), listSize);

		deinitialiseTaskTree();
	}


	@Test
	public void testReplaceElementsFromTree() {
		initialiseTaskTree();

		populateSampleTasks();

		ArrayList<Task> returnList, originalList;
		Task taskOld;
		String checkString, resultString, replaceTerm;

		// Get original list
		originalList = new ArrayList<Task>(_taskTree.getList());
		returnList = new ArrayList<Task>(_taskTree.getList());
		assertEquals(_taskTree.size(), returnList.size());

		// Check update name; only the name of this task will be changed
		originalList = new ArrayList<Task>(returnList);
		replaceTerm = "Milk is delicious";

		taskOld = returnList.get(FIRST_ELEMENT);
		checkString = taskOld.getName();
		_taskTree.updateName(taskOld, replaceTerm);
		returnList = new ArrayList<Task>(_taskTree.getList());
		assertNotEquals(checkString, replaceTerm);

		// Check update end time; only the end time of this task will be changed
		originalList = new ArrayList<Task>(returnList);
		checkString = originalList.toString();
		for (int i = 0; i < NUM_OF_ITEMS; i++) {
			_taskTree.updateEndTime(returnList.get(i), 0);
		}
		resultString = returnList.toString();
		assertNotEquals(resultString, checkString);

		deinitialiseTaskTree();
	}


	@Test
	public void testQueryTime() {
		initialiseTaskTree();

		populateSampleTasks();

		long lowerBound;
		long upperBound;
		ArrayList<Task> resultList;

		// Setting up test cases
		// first item (inclusive) to more than last element (inclusive)
		lowerBound = endTimes[FIRST_ELEMENT];
		upperBound = endTimes[LAST_ELEMENT] + FIVE_SECONDS;
		resultList = new ArrayList<Task>(_taskTree.queryEndTime(lowerBound, upperBound));
		assertTrue(resultList.size() == NUM_OF_ITEMS);

		// first item (inclusive) to last element (inclusive)
		lowerBound = endTimes[FIRST_ELEMENT];
		upperBound = endTimes[LAST_ELEMENT];
		resultList = new ArrayList<Task>(_taskTree.queryEndTime(lowerBound, upperBound));
		assertTrue(resultList.size() == NUM_OF_ITEMS);

		// lowerBound > upperBound
		lowerBound = endTimes[LAST_ELEMENT];
		upperBound = endTimes[FIRST_ELEMENT];
		resultList = new ArrayList<Task>(_taskTree.queryEndTime(lowerBound, upperBound));
		assertTrue(resultList.size() == 0);

		// item less than first element (inclusive) to first item (inclusive)
		lowerBound = endTimes[LAST_ELEMENT] - FIVE_SECONDS;
		upperBound = endTimes[LAST_ELEMENT];
		resultList = new ArrayList<Task>(_taskTree.queryEndTime(lowerBound, upperBound));
		assertTrue(resultList.size() == 1);

		deinitialiseTaskTree();
	}


	public void testSearchFlagAndPriority() {
		initialiseTaskTree();

		populateSampleTasks();

		FLAG_TYPE searchFlag;
		FLAG_TYPE lowerBoundFlag;
		FLAG_TYPE upperBoundFlag;

		PRIORITY_TYPE searchPriority;
		ArrayList<Task> returnList;

		// Get done flag
		searchFlag = Task.FLAG_TYPE.DONE;
		returnList = new ArrayList<Task>(_taskTree.searchFlag(searchFlag));
		assertEquals(returnList.size(), 1);

		// Get done flag
		searchFlag = Task.FLAG_TYPE.NULL;
		returnList = new ArrayList<Task>(_taskTree.searchFlag(searchFlag));
		assertEquals(returnList.size(), 4);

		// Query done flag
		lowerBoundFlag = Task.FLAG_TYPE.NULL;
		upperBoundFlag = Task.FLAG_TYPE.DONE;
		returnList = new ArrayList<Task>(_taskTree.queryFlag(lowerBoundFlag, upperBoundFlag));
		assertEquals(returnList.size(), 5);

		// Query done flag
		searchPriority = Task.PRIORITY_TYPE.HIGH;
		returnList = new ArrayList<Task>(_taskTree.queryPriority(searchPriority, searchPriority));
		assertEquals(returnList.size(), 1);

		// Query priority normal
		searchPriority = Task.PRIORITY_TYPE.NORMAL;
		returnList = new ArrayList<Task>(_taskTree.searchPriority(searchPriority));
		assertEquals(returnList.size(), 3);

		deinitialiseTaskTree();
	}

	@SuppressWarnings("unused")
	private void printList(List<Task> returnList) {
		int index;
		if (returnList.isEmpty()) {
			System.out.println("No item in list");
		} else {
			for (int i = 0; i < returnList.size(); i++) {
				index = i + 1;
				System.out.println("" + index + ". " + returnList.get(i));
			}
		}
		System.out.println();
	}
}
```
###### ui\assets\UI.fxml
``` fxml
                  <VBox prefHeight="432.0" prefWidth="324.0" HBox.hgrow="ALWAYS">
                     <HBox.margin>
                        <Insets />
                     </HBox.margin>
                     <children>
                        <Label fx:id="tableFloatHeader" prefHeight="25.0" prefWidth="388.0" text="Without deadline">
                           <font>
                              <Font name="Segoe UI" size="16.0" />
                           </font>
                           <VBox.margin>
                              <Insets />
                           </VBox.margin>
                        </Label>
                        <TableView fx:id="tableFloat" maxHeight="460.0" maxWidth="631.0" minHeight="244.0" minWidth="0.0" prefHeight="397.0" prefWidth="344.0">
                           <columns>
                              <TableColumn fx:id="idFloat" minWidth="30.0" prefWidth="30.0" resizable="false" text="ID" />
                              <TableColumn fx:id="taskFloat" maxWidth="331.0" minWidth="320.0" prefWidth="328.0" resizable="false" text="Task" />
                           </columns>
                           <columnResizePolicy>
                              <TableView fx:constant="CONSTRAINED_RESIZE_POLICY" />
                           </columnResizePolicy>
                        </TableView>
                     </children>
                  </VBox>
               </children>
               <VBox.margin>
                  <Insets left="18.0" right="18.0" top="10.0" />
               </VBox.margin>
            </HBox>
            <VBox alignment="CENTER" maxHeight="178.0" maxWidth="1100.0" minHeight="60.0" minWidth="785.0" prefHeight="95.0" prefWidth="1100.0" VBox.vgrow="ALWAYS">
               <children>
                  <Label fx:id="cmdMsg" alignment="CENTER" prefHeight="27.0" prefWidth="981.0" text="Subtitle" textAlignment="CENTER" textFill="#002dff">
                     <VBox.margin>
                        <Insets top="15.0" />
                     </VBox.margin>
                     <font>
                        <Font name="Segoe UI" size="18.0" />
                     </font>
                  </Label>
                  <HBox alignment="CENTER_LEFT" maxHeight="48.0" maxWidth="1249.0" minHeight="48.0" minWidth="785.0" prefHeight="48.0" prefWidth="1249.0" VBox.vgrow="ALWAYS">
                     <children>
                        <TextField fx:id="input" maxHeight="38.0" maxWidth="1062.0" minHeight="38.0" minWidth="785.0" onAction="#enterPressed" onKeyPressed="#showHistory" prefHeight="38.0" prefWidth="1062.0" promptText="Enter command here" HBox.hgrow="ALWAYS">
                           <HBox.margin>
                              <Insets />
                           </HBox.margin>
                           <font>
                              <Font name="Segoe UI" size="16.0" />
                           </font></TextField>
                     </children>
                  </HBox>
                  <Label fx:id="syntaxMsg" prefHeight="27.0" prefWidth="981.0" textAlignment="CENTER" textFill="#444444">
                     <VBox.margin>
                        <Insets bottom="10.0" />
                     </VBox.margin>
                     <font>
                        <Font name="Segoe UI" size="12.0" />
                     </font>
                  </Label>
               </children>
               <VBox.margin>
                  <Insets bottom="10.0" left="18.0" right="18.0" />
               </VBox.margin>
               <opaqueInsets>
                  <Insets />
               </opaqueInsets>
            </VBox>
         </children>
         <opaqueInsets>
            <Insets />
         </opaqueInsets>
         <padding>
            <Insets top="10.0" />
         </padding>
      </VBox>
   </children>
</AnchorPane>
```
###### ui\assets\UIHelpOverlay.fxml
``` fxml
<?import javafx.scene.web.*?>
<?import javafx.scene.control.*?>
<?import java.lang.*?>
<?import javafx.scene.layout.*?>

<AnchorPane fx:id="helpAnchorPane" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" prefHeight="340.0" prefWidth="420.0" xmlns="http://javafx.com/javafx/8.0.40" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ui.UIHelpOverlayController">
   <children>
      <WebView fx:id="helpContentView" layoutX="24.0" layoutY="41.0" onKeyPressed="#onKeyPressed" prefHeight="285.0" prefWidth="417.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
   </children>
</AnchorPane>
```
###### ui\assets\UIHelpOverlay.html
``` html
<html>
	<head>
	<style>
		body {
			background-color: #FBFBFB;
			text-align: center;
			font-family: "Trebuchet MS", Helvetica, sans-serif;
		    margin: 0;
		    padding: 0;
		}

		table {
			padding-left: 40px;
			text-align: left;
			width: 350px;
		}

		table th {
			text-align: left;
		}

		table.center {
		    margin-left:auto;
		    margin-right:auto;
		  }

	</style>

	</head>
	<body>
		<h1>List of Commands</h1>

		<table class="center">
			<tr>
				<th>Operation</th>
				<th>Command</th>
			</tr>
			<tr>
				<td>Add a task</td>
				<td>
					<code>add &lt;task_name&gt;</code>
				</td>
			</tr>
			<tr>
				<td>Delete a task</td>
				<td>
					<code>delete &lt;task_ID&gt;</code>
				</td>
			</tr>
			<tr>
				<td>Update a task</td>
				<td>
					<code>update &lt;task_ID&gt;</code>
				</td>
			</tr>
			<tr>
				<td>Search task(s)</td>
				<td>
					<code>search &lt;keyword&gt;</code>
				</td>
			</tr>
			<tr>
				<td>List task(s)</td>
				<td>
					<code>list</code>
				</td>
			</tr>
			<tr>
				<td>Mark a task(s)</td>
				<td>
					<code>mark &lt;task_ID&gt;</code>
				</td>
			</tr>
			<tr>
				<td>Undo</td>
				<td>
					<code>undo</code>
				</td>
			</tr>
			<tr>
				<td>Exit TaskBuddy</td>
				<td>
					<code>exit</code>
				</td>
			</tr>
		</table>
	</body>
</html>
```
###### ui\assets\UIStylesheet.css
``` css
.root {
	-fx-background-color: #FBFBFB;
}

.table-column {
    -fx-alignment: CENTER;
    -fx-text-fill: BLACK;
    -fx-font-weight: NORMAL;
	-fx-font: 12.0px 'Segoe UI', Frutiger, 'Frutiger Linotype', 'Dejavu Sans', 'Helvetica Neue', Arial, sans-serif;
}

.highPriority .table-cell {
    -fx-text-fill: RED;
}

.normalPriority .table-cell{
	-fx-text-fill: BLACK;
}

.lowPriority .table-cell{
	-fx-text-fill: FORESTGREEN;
}

.done .table-cell{
	-fx-text-fill: #BDBDBD;
}

.undone .table-cell{
	-fx-text-fill: BLACK;
}

.current .table-cell {
	-fx-font-weight: NORMAL;
}

.overdue .table-cell {
    -fx-font-weight: BOLD;
}
```
###### ui\UI.java
``` java
package ui;

import java.io.IOException;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Point2D;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import javafx.stage.Window;
import logger.LogHandler;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.layout.*;

public class UI extends Application {

	// File path
	private static final String RESOURCE_FILEPATH = "assets/UI.fxml";
	private static final String HELP_FILEPATH = "assets/UIHelpOverlay.fxml";
	private static final String UI_STYLESHEET_FILEPATH = "ui/assets/UIStylesheet.css";
	private static final String ICON_FILEPATH = "assets/UIIcon.png";

	// Message String constants
	private static final String ERR_LOADING_FILE = "Error loading UI: ";
	private static final String APP_TITLE = "TaskBuddy";

	private static UIController uIController;
	private static UIHelpOverlayController uIHelpOverlayController;
	private static Stage uIHelpStage;
	private static Scene uIHelpScene;
	private static Scene uiMainScene;
	private static boolean isInitialised;

	FXMLLoader uIMainLoader;
	FXMLLoader uIHelpLoader;

```
###### ui\UI.java
``` java
			AnchorPane uiHelpRoot = (AnchorPane) uIHelpLoader.load();
			uIHelpOverlayController = uIHelpLoader.getController();
			uIHelpScene = new Scene(uiHelpRoot);
			uIHelpStage.setScene(uIHelpScene);
			uIHelpStage.initStyle(StageStyle.UTILITY);

			isInitialised = true;

			LogHandler.getLog().finer(LogHandler.LOG_EXIT);

		} catch (IOException e) {
			String msg = String.format(ERR_LOADING_FILE, e);
			LogHandler.getLog().severe(msg);
			System.err.println(msg);
		}
	}

	public static UIController getController() {
		return uIController;
	}

	public static UIHelpOverlayController getUIHelpOverlayController() {
		return uIHelpOverlayController;
	}

	public boolean isInitialised() {
		return isInitialised;
	}

	public void showUIHelpOverlayStage() {

		// Platform.runLater is required to modify UI after starting JavaFx thread.
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				uIHelpStage.show();
				Point2D uICenterCoord = getWindowCenterCoor(uiMainScene.getWindow());
				Point2D uIHelpStartCoord = getRelativeStartCoorFromCenter(uICenterCoord, uIHelpStage);
				setStagePosition(uIHelpStartCoord, uIHelpStage);
			}
		});
	}

	public void hideUIHelpOverlayStage() {

		// Platform.runLater is required to modify UI after starting JavaFx thread.
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				uIHelpStage.hide();
			}
		});
	}

	private Point2D getWindowCenterCoor(Window uiWindow) {

		double xStartPos = uiWindow.getX();
		double xMidLen = uiWindow.getWidth() / 2;
		double xPos = xStartPos + xMidLen;

		double yStartPos = uiWindow.getY();
		double yMidLen = uiWindow.getHeight() / 2;
		double yPos = yStartPos + yMidLen;

		return new Point2D(xPos, yPos);
	}

	private Point2D getRelativeStartCoorFromCenter(Point2D center, Stage stage) {
		double width = stage.getWidth();
		double xPos = center.getX() - width/2;

		double height = stage.getHeight();
		double yPos = center.getY() - height/2;

		return new Point2D(xPos, yPos);
	}

	private void setStagePosition(Point2D coord, Stage stage) {
		stage.setX(coord.getX());
		stage.setY(coord.getY());
	}

```
###### ui\UIController.java
``` java
public class UIController implements Initializable {

	// Message string constants
	private static final String MSG_CMD_WELCOME = "Welcome! Loading your tasks...";
	private static final String MSG_PENDING_HELLO = "Hello %s,";
	private static final String MSG_EMPTY = "";
	private static final String MSG_EMPTY_TABLE = "Nothing here";
	private static final String MSG_COUNT_OVERDUE = "Overdue [ %s ]";
	private static final String MSG_COUNT_PENDING = "Pending [ %s ]";
	private static final String MSG_COUNT_DONE = "Done [ %s ]";
	private static final String EMPTY_TIME_DATE = "Getting time...";

```
###### ui\UIController.java
``` java
	// CSS node constants
	private static final String CSS_PRIORITY_HIGH = "highPriority";
	private static final String CSS_PRIORITY_LOW = "lowPriority";
	private static final String CSS_FLAG_DONE = "done";
	private static final String CSS_OVERDUE = "overdue";

	// FXML constants
	@FXML
	private Label pendingMsg;
	@FXML
	private Label timeDateMsg;
	@FXML
	private Label cmdMsg;
	@FXML
	private Label syntaxMsg;
	@FXML
	private Label tableFloatHeader;
	@FXML
	private Label tableTimedHeader;
	@FXML
	private Label overdueCount;
	@FXML
	private Label pendingCount;
	@FXML
	private Label doneCount;
```
###### ui\UIController.java
``` java
	private static UI uI;
	private static UIController uIController;
	private List<Task> floatingTaskList;
	private List<Task> nonFloatingTaskList;
	private ArrayList<String> inputBuffer = new ArrayList<>();
	ObservableList<UITask> dataTimed = FXCollections.observableArrayList();
	ObservableList<UITask> dataFloat = FXCollections.observableArrayList();

```
###### ui\UIController.java
``` java
	static UIController getUIController() {
		uIController = UI.getController();
		return uIController;
	}

	@Override
	public void initialize(URL fxmlFileLocation, ResourceBundle resources) {

		// Label fields
		cmdMsg.setText(MSG_CMD_WELCOME);
		String username = System.getProperty("user.name");

		pendingMsg.setText(String.format(MSG_PENDING_HELLO, username));

		// Initialize and reset UI Label fields
		timeDateMsg.setText(EMPTY_TIME_DATE);
		overdueCount.setText(EMPTY_STRING);
		pendingCount.setText(EMPTY_STRING);
		doneCount.setText(EMPTY_STRING);

		// Table
```
###### ui\UIController.java
``` java
		tableTimed.setPlaceholder(new Label(MSG_EMPTY_TABLE));
		tableFloat.setPlaceholder(new Label(MSG_EMPTY_TABLE));

		tableTimed.setFocusTraversable(false);
		tableFloat.setFocusTraversable(false);

		// Command help tips listener
		input.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				processSyntaxMessage(oldValue, newValue);
			}
		});
	}

```
###### ui\UIController.java
``` java
			while (!uI.isInitialised()) {
				try {
					Thread.sleep(0);
				} catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
				}
			}
		}
	}

```
###### ui\UIController.java
``` java
	void setInput(String str) {
		input.setText(str);
		input.positionCaret(str.length());
	}

	void clearInput() {
		input.clear();
	}

	void setOutputMsg(String str) {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				cmdMsg.setText(str);
			}
		});
	}

	void setTimeDateMsg(String str) {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				timeDateMsg.setText(str);
			}
		});
	}

	void setSyntaxMsg(String str) {
		syntaxMsg.setText(str);
	}

	void setDoneCount(int count) {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				String str = String.format(MSG_COUNT_DONE, count);
				doneCount.setText(str);
			}
		});
	}

	void setPendingCount(int count) {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				String str = String.format(MSG_COUNT_PENDING, count);
				pendingCount.setText(str);
			}
		});
	}

	void setOverdueCount(int count) {
		Platform.runLater(new Runnable() {
			@Override
			public void run() {
				String str = String.format(MSG_COUNT_OVERDUE, count);
				overdueCount.setText(str);
			}
		});
	}

	void showUIHelpOverlay() {
		uI.showUIHelpOverlayStage();
	}

	void hideUIHelpOverlay() {
		uI.hideUIHelpOverlayStage();
	}

```
###### ui\UIController.java
``` java
	private void processSyntaxMessage(String oldValue, String newValue) {
		String oldCommand = EMPTY_STRING;
		String newCommand = EMPTY_STRING;

		if (!oldValue.isEmpty() && oldValue != null) {
			oldCommand = StringUtil.getFirstWord(oldValue);
		}
		if (!newValue.isEmpty() && newValue != null) {
			newCommand = StringUtil.getFirstWord(newValue);
		}

		if (newCommand == null) {
			return;
		}

		if (newCommand.equals(oldCommand)) {
			return;
		} else {
			if (isValidCmd(newCommand)) {
				CommandProcessor cp = parser.CommandProcessor.getInstance();
				Command commandType = cp.getCmdType(newCommand);
				String syntaxMessage = newCommand + " " + commandType.getHelpInfo();
				setSyntaxMsg(syntaxMessage);
			} else {
				setSyntaxMsg(MSG_EMPTY);
			}
		}
	}

	private boolean isValidCmd(String input) {
		return CommandProcessor.getInstance().getEffectiveCmd(input) == null ? false : true;
	}

}
```
###### ui\UIHelper.java
``` java
	public static void setOutputMsg(String s) {
		uiController.setOutputMsg(s);
	}

	public static void showHelpPanel() {
		uiController.showUIHelpOverlay();
	}

	public static void setDate(String date) {
		uiController.setTimeDateMsg(date);
	}

	public static void setPendingCount(int count) {
		uiController.setPendingCount(count);
	}

	public static void setOverdueCount(int count) {
		uiController.setOverdueCount(count);
	}

	public static void setDoneCount(int count) {
		uiController.setDoneCount(count);
	}
}
```
###### ui\UIHelpOverlayController.java
``` java
package ui;

import java.net.URL;
import java.util.ResourceBundle;

import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.layout.AnchorPane;
import javafx.scene.web.WebEngine;
import javafx.scene.web.WebView;

public class UIHelpOverlayController implements Initializable {

	// Constants
	private final String HTML_FILEPATH = "/ui/assets/UIHelpOverlay.html";

	@FXML private WebView helpContentView;
	@FXML private AnchorPane helpAnchorPane;

	public UIHelpOverlayController() {}

	@Override
	public void initialize(URL fxmlFileLocation, ResourceBundle resources) {

		String url = UIHelpOverlayController.class.getResource(HTML_FILEPATH).toExternalForm();

		WebEngine webEngine = helpContentView.getEngine();
		webEngine.load(url);
	}

	public void onKeyPressed() {
		UIController uIController = UIController.getUIController();
		uIController.hideUIHelpOverlay();
	}
}
```
###### ui\UITask.java
``` java
	public String getSDate() {
		return getSDateString(taskObj);
	}

	public long getEndTime() {
		return taskObj.getEndTime();
	}

	public PRIORITY_TYPE getPriority() {
		return taskObj.getPriority();
	}

	public FLAG_TYPE getFlag() {
		return taskObj.getFlag();
	}

}
```
