# A0125496X
###### constants\CmdParameters.java
``` java
/**
 * Keeps a list of parameter constants to be resolved by both LanguageProcessor and Command
 * 
 * @author Yan Chan Min Oo 
 */
package constants;

public class CmdParameters {
	public static final String PARAM_NAME_TASK_NAME = "ttn";
	public static final String PARAM_NAME_TASK_SNAME = "ttsn";
	public static final String PARAM_NAME_TASK_ID = "tid";
	public static final String PARAM_NAME_TASK_STARTTIME = "tst";
	public static final String PARAM_NAME_TASK_ENDTIME = "tet";
	public static final String PARAM_NAME_TASK_PRIORITY = "tp";
	public static final String PARAM_VALUE_TASK_PRIORITY_HIGH = "tph";
	public static final String PARAM_VALUE_TASK_PRIORITY_NORM = "tpn";
	public static final String PARAM_VALUE_TASK_PRIORITY_LOW = "tpl";
	public static final String PARAM_NAME_CMD_SEARCH = "cs";
	public static final String PARAM_NAME_LIST_FLAG = "lf";
	public static final String PARAM_NAME_MARK_FLAG = "mf";
	public static final String PARAM_VALUE_LIST_DONE = "ld";
	public static final String PARAM_VALUE_LIST_ALL = "la";
	public static final String PARAM_VALUE_LIST_PRIORITY = "lp";
	public static final String PARAM_VALUE_MARK_UNMARK = "um";
}
```
###### logic\command\CmdAdd.java
``` java
/**
 * The add command
 * 
 * @author Yan Chan Min Oo
 */
package logic.command;

import constants.CmdParameters;
import parser.ParserConstants;
import taskCollections.Task;
import taskCollections.Task.FLAG_TYPE;
import taskCollections.Task.PRIORITY_TYPE;
import util.TimeUtil;

public class CmdAdd extends Command {

	/*
	 * Constants
	 */
	// Message constants
	private static final String MSG_TASKADDED = "Added : %1$s";
	private static final String MSG_TASKNAMENOTGIVEN = "Please enter a task name";
	private static final String MSG_STARTAFTEREND = "Specified start time should be before end time";

	// Help Info
	private static final String HELP_INFO_ADD = "<task_name> [%1$s <start_time>] [%2$s <end_time>] [%2$s <end_time>] [%3$s high/normal/low/h/n/l]";

	/*
	 * Variables for internal use
	 */
	private Task addTask;
	private String taskName;
	private String taskStartTime;
	private String taskEndTime;
	private String taskPriority;
	
	public CmdAdd(){
	}
	
	public CmdAdd(String taskName){
		this.taskName = taskName;
	}

	@Override
	public CommandAction execute() {

		addTask = getTask(); // Tries to get the task object (if available). Usually not null if this is called from an undo

		if (addTask == null) { // Not an existing task. Create a task object from scratch

			// Get details of the task to add
			if (taskName == null) {
				taskName = getParameterValue(CmdParameters.PARAM_NAME_TASK_NAME);
			}
			if (taskName == null || taskName.equals("")) {
				return new CommandAction(MSG_TASKNAMENOTGIVEN, false, _taskTree.getList());
			}
			taskStartTime = getParameterValue(CmdParameters.PARAM_NAME_TASK_STARTTIME);
			taskEndTime = getParameterValue(CmdParameters.PARAM_NAME_TASK_ENDTIME);
			taskPriority = getParameterValue(CmdParameters.PARAM_NAME_TASK_PRIORITY);

			assignDefaults(); // Assign defaults for unspecified fields

			// Convert the start/end times to a format we can use for calculation
			long taskStartTimeL = TimeUtil.sysStringToLongTime(taskStartTime);
			long taskEndTimeL = TimeUtil.sysStringToLongTime(taskEndTime);

			// Ensure the dates given are valid
			if (!isValidTime(taskStartTimeL, taskEndTimeL)) {
				return new CommandAction(MSG_STARTAFTEREND, false, _taskTree.searchFlag(FLAG_TYPE.NULL));
			}

			// Convert the priority to a format we can use for storing
			PRIORITY_TYPE taskPriorityP = getPriorityValue(taskPriority);

			addTask = new Task(taskName, taskStartTimeL, taskEndTimeL, Task.FLAG_TYPE.NULL, taskPriorityP);
		}

		_taskTree.add(addTask); // Add the task to the collection

		return new CommandAction(String.format(MSG_TASKADDED, taskName), true, _taskTree.searchFlag(FLAG_TYPE.NULL));
	}

	@Override
	public CommandAction undo() {
		Command delete = new CmdDelete();
		delete.setTask(addTask);
		return delete.execute();
	}

	/**
	 * Assign default values to unspecified parameters
	 */
	private void assignDefaults() {
		if (taskStartTime == null) { // Default start time
			taskStartTime = "" + Task.DATE_NULL;
		}
		if (taskEndTime == null) { // Default end time
			taskEndTime = "" + Task.DATE_NULL;
		}
		if (taskPriority == null) { // Default priority
			taskPriority = CmdParameters.PARAM_VALUE_TASK_PRIORITY_NORM;
		}
	}

	/**
	 * Converts the priority from string to a format suitable for storage
	 */
	private PRIORITY_TYPE getPriorityValue(String priority) {
		switch (priority) {
		case CmdParameters.PARAM_VALUE_TASK_PRIORITY_HIGH:
			return PRIORITY_TYPE.HIGH;
		case CmdParameters.PARAM_VALUE_TASK_PRIORITY_LOW:
			return PRIORITY_TYPE.LOW;
		default:
			return PRIORITY_TYPE.NORMAL;
		}
	}

	/**
	 * Checks if the start time is before the end time
	 * @param startTime
	 * 			The start time
	 * @param endTime
	 * 			The end time
	 * @return
	 * 			True if the time is valid, false if it isn't
	 */
	private boolean isValidTime(long startTime, long endTime) {
		if (endTime == 0 && startTime == 0) {
			return true;
		} else {
			return TimeUtil.compareMinTime(startTime, endTime) < 0;
		}
	}

	@Override
	public String[] getRequiredFields() {
		return new String[] { CmdParameters.PARAM_NAME_TASK_NAME };
	}

	@Override
	public String[] getOptionalFields() {
		return new String[] { CmdParameters.PARAM_NAME_TASK_STARTTIME, CmdParameters.PARAM_NAME_TASK_ENDTIME,
				CmdParameters.PARAM_NAME_TASK_PRIORITY };
	}

	@Override
	public String getHelpInfo() {
		return String.format(HELP_INFO_ADD, ParserConstants.TASK_SPECIFIER_STARTTIME,
				ParserConstants.TASK_SPECIFIER_ENDTIME, ParserConstants.TASK_SPECIFIER_PRIORITY);
	}
}
```
###### logic\command\Command.java
``` java
/**
 * Specifies the format all supported commands should follow, as well as hold the data structure which
 * most supported commands will need.
 *
 * @author Yan Chan Min Oo
 */

package logic.command;

import java.util.HashMap;
import java.util.Stack;

import taskCollections.Task;
import taskCollections.TaskTree;

public abstract class Command {

	/*
	 * List of data structures to be used by command and its subclasses
	 */

	// Stores the list of parameters. Name of parameter -> Value of parameter
	private HashMap<String,String> parameters;
	// Stores the list of command which were executed by the user
	private static Stack<Command> history = new Stack<Command>();
	// The task that the command is trying to manipulate
	private Task task;
	// The task tree which all commands will reference to
	protected static TaskTree _taskTree;

	public Command(){
		parameters = new HashMap<String,String>();
	}

	/**
	 * Executes the command
	 * @return a CommandAction object
	 */
	public abstract CommandAction execute();

	/**
	 * Undo an operation. Applies to manipulative commands only
	 * @return a CommandAction object
	 */
	public abstract CommandAction undo();

	/**
	 * Get the list of fields that are required to run this command
	 * @return List of required parameter names
	 *
	 */
	public abstract String[] getRequiredFields();

	/**
	 * Get the list of optional fields that can be used to run this command
	 * @return List of required parameter names
	 */
	public abstract String[] getOptionalFields();
	
	/**
	 * Get the message to display the syntax of a particular command
	 * @return String of the message
	 */
	public abstract String getHelpInfo();

	/**
	 * Sets the parameters required for some commands. Should be called before calling
	 * execute()
	 * @param parameterName
	 * 				The name of parameter to set
	 * @param parameterValue
	 * 				The value of parameter to set
	 */
	public void setParameter(String parameterName, String parameterValue){
		parameters.put(parameterName,parameterValue);
	}

	/**
	 * Returns the value of a given parameter name.
	 * @param parameterName
	 * 				The parameter name to look up
	 * @return The parameter value it's found, null if it isn't
	 */
	protected String getParameterValue(String parameterName){
		return parameters.get(parameterName);
	}

	/**
	 * Sets the task to be worked on. Should be called before calling executed()
	 * @param t
	 * 				The task to set
	 */
	public void setTask(Task t){
		task = t;
	}

	/**
	 * Returns the task to be worked on
	 * @return The task if it's found, null if it isn't
	 */
	public Task getTask(){
		return task;
	}

	/**
	 * Add a command to the list of history. To be called after successfully executing a
	 * undoable command
	 * @param toAdd
	 * 				The command to add to the list of history
	 */
	public static void addHistory(Command toAdd){
		history.add(toAdd);
	}

	/**
	 * Gets and removes the last command which was executed
	 * @return The last command which was executed
	 */
	protected static Command extractHistory(){
		if (history.isEmpty()) {	
			return null;			
		} else {					
			return history.pop();
		}							
	}

	public static void init(){
		_taskTree = TaskTree.getTaskTree();
	}
}
```
###### logic\TaskBuddy.java
``` java
/**
 * Start point of the entire program.
 *
 * @author Yan Chan Min Oo
 */

package logic;

import java.util.List;
import java.util.logging.Logger;

import logger.LogHandler;
import logic.command.CmdList;
import logic.command.Command;
import logic.command.CommandAction;
import ui.UIHelper;
import util.TimeUtil;
import parser.LanguageProcessor;
import storage.SettingsFileHandler;
import taskCollections.Task;
import taskCollections.Task.FLAG_TYPE;
import taskCollections.TaskTree;

public class TaskBuddy {

	/*
	 * Constants
	 */
	private static final String CMD_FILENAME = "commands.xml";
	private static final String MSG_INVALIDCMD = "Please enter a valid command. For more info, enter help";
	private static final String MSG_TASKFILE_NOTFOUND = "Please enter the name or location of file to open or create. File name should end with '.xml'";
	private static final String MSG_TASKFILE_REPROMPT = "Please enter another file name";
	/*
	 * Global variables
	 */
	private static Logger _log;
	private static LanguageProcessor _lp;
	private static String _taskFileName;
	private static TaskTree _taskTree;

	public static void main(String[] args) {

		// Initialise all the variables
		init();

		// (Loop) Execute commands
		runCommands();
	}

	/**
	 * Initialises all the necessary variables
	 */
	private static void init() {
		_log = LogHandler.getLog(); // Init the log

		// Set up the UI
		UIHelper.createUI();
		UIHelper.setDate(TimeUtil.getUIFormattedDate(System.currentTimeMillis()));

		// Init the parser component
		_lp = LanguageProcessor.getInstance();
		if (!_lp.init(CMD_FILENAME)) {
			_log.severe("TaskBuddy: Cmd list init failed");
		}

		initTaskFile(); // Init the storage component for tasks
		initTaskTree(_taskFileName); // Load the tasks to task collection
		Command.init(); // Init the logic component
		displayTaskList(); // Display the task list on the UI
	}

	/**
	 * Displays the task list
	 */
	private static void displayTaskList() {
		Command list = new CmdList();
		resolveCmdAction(list.execute(), list);
	}

	/**
	 * Creates / Open the task file
	 */
	private static void initTaskFile() {
		SettingsFileHandler settings = SettingsFileHandler.getInstance();

		if (!settings.init()) { // Create the settings file if it's not found
			UIHelper.setOutputMsg(MSG_TASKFILE_NOTFOUND);
			// Write the task file path to settings
			settings.alterSettingsFile(ensureCorrectFileNameFormat(UIHelper.getUserInput()));
		}
		
		// Create the task file path defined in settings
		while (!settings.initializeTaskFile()) {
			// Unable to initialise task file. Open/Create another file
			UIHelper.setOutputMsg(MSG_TASKFILE_REPROMPT);
			settings.alterSettingsFile(ensureCorrectFileNameFormat(UIHelper.getUserInput()));
		}
		
		_taskFileName = settings.getTaskFile(); // Get the final task file name
	}

	private static void initTaskTree(String filePath) {
		_taskTree = TaskTree.newTaskTree(filePath);
	}
	
	private static String ensureCorrectFileNameFormat(String filePath){
		if(!filePath.endsWith(".xml")){
			filePath = filePath + ".xml";
		}
		return filePath;
	}

	/**
	 * Main routine of the program to execute commands
	 */
	private static void runCommands() {
		do {
			setUITasksCount(); // Display the list of statuses of tasks
			String in = getInput(); // Get the input from user
			Command toExecute = _lp.resolveCmd(in); // Parse the command
			
			if (toExecute == null) {
				// Unable to parse command
				UIHelper.setOutputMsg(MSG_INVALIDCMD);
				continue;
			}

			// Perform relevant actions from the executed command
			resolveCmdAction(toExecute.execute(), toExecute);
		} while (true);
	}

```
###### parser\CommandProcessor.java
``` java
/**
 * Resolves command related stuff
 * 
 */
package parser;

import java.util.HashMap;

import logic.command.*;
import storage.CommandFileHandler;
import util.StringUtil;

/**
 * @author Yan Chan Min Oo
 *
 */
public class CommandProcessor {
	/*
	 * Constants
	 */
	public static final String CONFIG_CMD_ADD = "add";
	public static final String CONFIG_CMD_DELETE = "delete";
	public static final String CONFIG_CMD_EXIT = "exit";
	public static final String CONFIG_CMD_HELP = "help";
	public static final String CONFIG_CMD_LIST = "list";
	public static final String CONFIG_CMD_MARK = "mark";
	public static final String CONFIG_CMD_SEARCH = "search";
	public static final String CONFIG_CMD_UNDO = "undo";
	public static final String CONFIG_CMD_UPDATE = "update";
	
	/*
	 * Variables
	 */
	private HashMap<String, String> cmdTable;
	private static CommandProcessor cmdP;
	
	private CommandProcessor(){
	}
	
	public static CommandProcessor getInstance(){
		if(cmdP == null){
			cmdP = new CommandProcessor();
		}
		return cmdP;
	}
	
	/**
	 * Initialises the command xml file
	 * @param cmdFileName
	 * 			The command file to initialise
	 * @return
	 * 			Return true if initialisation is successful, false otherwise
	 */
	public boolean initCmdList(String cmdFileName) {
		try {
			CommandFileHandler cf = new CommandFileHandler();
			if(!cf.loadCommandFile(cmdFileName)){
				cf.generateCommandFile(cmdFileName);
			}
			cmdTable = cf.getCmdTable();
			addDefaultCmds();
			return true;
		} catch (Exception e) {
			System.out.println(e);
			return false;
		}
	}
	
	/**
	 * Extracts the command string to execute
	 * 
	 * @param userCmd
	 *            The entire user input string
	 * @return The command string
	 */
	public String getCmd(String userCmd) {
		return StringUtil.getFirstWord(userCmd);
	}
	
	public Command getCmdType(String userCmd) {
		String actualCmd = getEffectiveCmd(userCmd);

		if (actualCmd == null) {// Unable to resolve the command. Try to use the default command
			actualCmd = userCmd;
		}

		switch (actualCmd) {
			case CONFIG_CMD_ADD:
				return new CmdAdd();
			case CONFIG_CMD_DELETE:
				return new CmdDelete();
			case CONFIG_CMD_EXIT:
				return new CmdExit();
			case CONFIG_CMD_HELP:
				return new CmdHelp();
			case CONFIG_CMD_LIST:
				return new CmdList();
			case CONFIG_CMD_MARK:
				return new CmdMark();
			case CONFIG_CMD_SEARCH:
				return new CmdSearch();
			case CONFIG_CMD_UNDO:
				return new CmdUndo();
			case CONFIG_CMD_UPDATE:
				return new CmdUpdate();
			default:
				return null;
		}
	}
	
	public String getEffectiveCmd(String cmd){
		return cmdTable.get(cmd);
	}
	
	private void addDefaultCmds(){
		cmdTable.put(CONFIG_CMD_DELETE, CONFIG_CMD_DELETE);
		cmdTable.put(CONFIG_CMD_ADD, CONFIG_CMD_ADD);
		cmdTable.put(CONFIG_CMD_EXIT, CONFIG_CMD_EXIT);
		cmdTable.put(CONFIG_CMD_HELP, CONFIG_CMD_HELP);
		cmdTable.put(CONFIG_CMD_LIST, CONFIG_CMD_LIST);
		cmdTable.put(CONFIG_CMD_MARK, CONFIG_CMD_MARK);
		cmdTable.put(CONFIG_CMD_SEARCH, CONFIG_CMD_SEARCH);
		cmdTable.put(CONFIG_CMD_UNDO, CONFIG_CMD_UNDO);
		cmdTable.put(CONFIG_CMD_UPDATE, CONFIG_CMD_UPDATE);
	}

}
```
###### parser\LanguageProcessor.java
``` java
package parser;

import logic.command.*;
import util.StringUtil;

import java.util.Arrays;
import java.util.HashSet;
import java.util.logging.Logger;

import constants.CmdParameters;
import logger.LogHandler;

/**
 * Translates and breaks natural language down for computation
 *
 * @author Yan Chan Min Oo
 *
 */

public class LanguageProcessor {
	/*
	 * Variables
	 */
	private static LanguageProcessor langP; // A copy of itself
	private static CommandProcessor cmdP;
	private static TimeProcessor timeP;
	private static Logger parseLog;

	/*
	 * Constant
	 */
	// <User input>: <Parsed parameters> [Optional message]
	private static final String LOG_FORMAT_RESULT = "%1$s -> %2$s | %3$s"; 
	private static final String LOG_MSG_INVALIDCMD = "Invalid command";
	private static final String LOG_MSG_NOPARAM = "No parameters given";
	private static final String LOG_MSG_REQUIRED_NOTFOUND = "Required field not found";
	private static final String LOG_MSG_OPTIONAL_INVALID = "Invalid optional field";
	private static final String LOG_MSG_SUCCESSCMD = "Cmd parsed successfully";
	
	private static final String REGEX_LIMIT = ParserConstants.DELIMITER_TOKEN + "\\w+"; // The pattern to determine a flag
	private static final String FIELD_INVALID = ""; // Denotes a field is invalid

	private LanguageProcessor() {
	}

	/**
	 * Get an instance of itself
	 * 
	 * @return The instance of itself
	 */
	public static LanguageProcessor getInstance() {
		if (langP == null) {
			langP = new LanguageProcessor();
		}

		return langP;
	}

	/**
	 * Initialises all the parser sub components
	 * 
	 * @param cmdFileName
	 *            The command file to use for its alternative commands
	 * @return True if the command file is initialises successfully, false
	 *         otherwise
	 */
	public boolean init(String cmdFileName) {
		cmdP = CommandProcessor.getInstance();
		timeP = TimeProcessor.getInstance();
		parseLog = LogHandler.getLog();
		return cmdP.initCmdList(cmdFileName);
	}

	/**
	 * Extracts the task name from an input, which is the string in the
	 * parameters until the first flag
	 * 
	 * @param userCmd
	 *            The string to extract from
	 * @return The extracted task name
	 */
	private String getTaskName(String userCmd) {
		String taskName = StringUtil.getStringAfter(userCmd, "", REGEX_LIMIT);
		return StringUtil.trim(taskName);
	}

	/**
	 * Extracts the specified task name from an input, which is the string after
	 * the name flag to the next flag
	 * 
	 * @param userCmd
	 *            The string to extract from
	 * @return The extracted task name
	 */
	private String getTaskSName(String userCmd) {
		String taskName = StringUtil.getStringAfter(userCmd, ParserConstants.TASK_SPECIFIER_TASKNAME, REGEX_LIMIT);
		return StringUtil.trim(taskName);
	}

	/**
	 * Extracts the task ID from an input, which is the first word in the
	 * parameters
	 * 
	 * @param userCmd
	 *            The string to extract from
	 * @return The extracted task ID
	 */
	private String getTaskID(String userCmd) {
		String id = StringUtil.getFirstWord(userCmd);

		if (id != null) { // ID is found
			try {
				Integer.parseInt(id);
				return id;
			} catch (NumberFormatException e) {
				return FIELD_INVALID; // This field is invalid for sure
			}
		}
		return null; // Unable to find task ID
	}

	/**
	 * Extracts the search term from an input, which is the entire parameter
	 * 
	 * @param userCmd
	 *            The string to extract from
	 * @return The extracted search term
	 */
	private String getSearchTerm(String userCmd) {
		return userCmd;
	}

	/**
	 * Extracts the end time from an input, which is the string after end time
	 * flag to the next flag
	 * 
	 * @param userCmd
	 *            The string to extract from
	 * @return The extracted end time
	 */
	private String getEndTime(String userCmd) {
		userCmd = StringUtil.getStringAfter(userCmd, ParserConstants.TASK_SPECIFIER_ENDTIME, REGEX_LIMIT);
		return StringUtil.trim(userCmd);
	}

	/**
	 * Extracts the start time from an input, which is the string after start
	 * time flag to the next flag
	 * 
	 * @param userCmd
	 *            The string to extract from
	 * @return The extracted start time
	 */
	private String getStartTime(String userCmd) {
		userCmd = StringUtil.getStringAfter(userCmd, ParserConstants.TASK_SPECIFIER_STARTTIME, REGEX_LIMIT);
		return StringUtil.trim(userCmd);
	}

	/**
	 * Extracts the priority from an input, which is the string after priority flag
	 * to the next flag
	 * @param userCmd
	 * 			The string to extract from
	 * @return
	 * 			The extracted priority
	 */
	private String getPriority(String userCmd) {
		String priority = StringUtil.getStringAfter(userCmd, ParserConstants.TASK_SPECIFIER_PRIORITY, REGEX_LIMIT);
		if (priority == null) {
			return null;
		}
		return resolvePriority(priority.trim());
	}

	/**
	 * Resolve a priority specifier (high/norm/low) to its respective value in parameters
	 * @param priority
	 * 			The priority to resolve
	 * @return
	 * 			The resolved priority
	 */
	private String resolvePriority(String priority) {
		// High priority
		for (String aPriority : ParserConstants.TASK_PRIORITY_HIGH) {
			if (aPriority.equalsIgnoreCase(priority)) {
				return CmdParameters.PARAM_VALUE_TASK_PRIORITY_HIGH;
			}
		}
		// Norm priority
		for (String aPriority : ParserConstants.TASK_PRIORITY_NORM) {
			if (aPriority.equalsIgnoreCase(priority)) {
				return CmdParameters.PARAM_VALUE_TASK_PRIORITY_NORM;
			}
		}
		// Low priority
		for (String aPriority : ParserConstants.TASK_PRIORITY_LOW) {
			if (aPriority.equalsIgnoreCase(priority)) {
				return CmdParameters.PARAM_VALUE_TASK_PRIORITY_LOW;
			}
		}
		return FIELD_INVALID; // Unable to resolve priority
	}

	/**
	 * Get the unmark option if it is available
	 * @param userCmd
	 * 			The string to analyse
	 * @return  Returns the unmark flag if it is available, null otherwise
	 */
	private String getMarkOption(String userCmd) {
		if (userCmd.contains(ParserConstants.TASK_MARK_UNMARK)) {
			return CmdParameters.PARAM_VALUE_MARK_UNMARK;
		} else {
			return null;
		}
	}

	/**
	 * Get the list flags
	 * @param userCmd
	 * 			The string to analyse
	 * @return Returns the list flag if it is found, null otherwise
	 */
	private String getListOption(String userCmd) {
		String flag = StringUtil.getFirstWord(userCmd);

		if (flag == null || flag.isEmpty()) {
			return null;
		} else if (StringUtil.getStringAfter(userCmd, flag, "") != null) {
			return FIELD_INVALID;
		} else if (flag.equals(ParserConstants.TASK_FILTER_ALL)) {
			return CmdParameters.PARAM_VALUE_LIST_ALL;
		} else if (flag.equals(ParserConstants.TASK_FILTER_DONE)) {
			return CmdParameters.PARAM_VALUE_LIST_DONE;
		} else if (flag.equals(ParserConstants.TASK_SPECIFIER_PRIORITY)) {
			return CmdParameters.PARAM_VALUE_LIST_PRIORITY;
		} else {
			return FIELD_INVALID;
		}
	}

	/**
	 * Resolves a user input command to a command instance
	 * @param userCmd
	 * 			The string to resolve
	 * @return
	 * 			The command instance
	 */
	public Command resolveCmd(String userCmd) {
		if (cmdP == null) { // If this is not initialised yet, do not allow any operations
			return null;
		}

		String cmd = cmdP.getCmd(userCmd); // Extract the command from input
		Command toExecute = cmdP.getCmdType(cmd); // Look up the command table

		if (toExecute == null) { // Not a valid command since look up in cmd table failed
			parseLog.info(String.format(LOG_FORMAT_RESULT, userCmd, "", LOG_MSG_INVALIDCMD));
			return null;
		}

		// Remove the command from the string, leaving just the parameters behind
		String param = StringUtil.removeFirstWord(userCmd);
		
		if (param == null) { // No parameters to process
			if (toExecute.getRequiredFields().length == 0) { // No required fields, valid cmd
				parseLog.info(String.format(LOG_FORMAT_RESULT, userCmd, "", LOG_MSG_NOPARAM));
				return toExecute;
			} else { // Invalid command since the required fields are not fullfilled
				return null;
			}
		}

		// Checks whether the flags given by the user is valid
		if (!hasValidFlags(toExecute.getOptionalFields(), userCmd)) {
			return null;
		}
		
		StringBuilder parameters = new StringBuilder(); // For logging purposes

		// Extract all required fields which are declared in commands
		for (String requiredField : toExecute.getRequiredFields()) {
			
			String paramValue = extractParameter(requiredField, param);
			parameters.append(requiredField + ": " + paramValue + "    ");
			
			// Invalid command since the required fields aren't there
			if (paramValue == null || paramValue.equals(FIELD_INVALID)) {
				parseLog.info(String.format(LOG_FORMAT_RESULT, userCmd, 
						parameters, LOG_MSG_REQUIRED_NOTFOUND));
				return null;
			}
			// Set the parameter for this field
			toExecute.setParameter(requiredField, paramValue);
		}
		// Extract all optional fields which are declared in commands
		for (String optionalField : toExecute.getOptionalFields()) {
			
			String paramValue = extractParameter(optionalField, param);
			parameters.append(optionalField + ": " + paramValue + "    ");
			
			if (paramValue != null) { // User entered something for this field
				
				// Invalid command since a field is misused
				if (paramValue.equals(FIELD_INVALID)) {
					parseLog.info(String.format(LOG_FORMAT_RESULT, userCmd,
							parameters, LOG_MSG_OPTIONAL_INVALID));
					return null;
				}
				// Set the parameter for this field
				toExecute.setParameter(optionalField, paramValue);
			}
		}
		
		parseLog.info(String.format(LOG_FORMAT_RESULT, userCmd,parameters,LOG_MSG_SUCCESSCMD));
		return toExecute;
	}

	/**
	 * Analyses the full parameter string, and extracts the necessary info
	 * specified by paramName. Does validation and conversion of parameters as
	 * well
	 *
	 * @param paramName
	 *            The type of parameter to extract
	 * @param fullParam
	 *            The entire parameter string to analyse and extract the
	 *            parameter value from
	 * @return The extracted parameter value, or null if extraction is not
	 *         successful
	 */
	private String extractParameter(String paramName, String fullParam) {
		String paramValue = null;
		switch (paramName) {
			case CmdParameters.PARAM_NAME_TASK_NAME:
				paramValue = getTaskName(fullParam);
				break;
			case CmdParameters.PARAM_NAME_TASK_SNAME:
				paramValue = getTaskSName(fullParam);
				break;
			case CmdParameters.PARAM_NAME_TASK_ID:
				paramValue = getTaskID(fullParam);
				break;
			case CmdParameters.PARAM_NAME_CMD_SEARCH:
				paramValue = getSearchTerm(fullParam);
				break;
			case CmdParameters.PARAM_NAME_TASK_ENDTIME:
				paramValue = resolveTime(getEndTime(fullParam));
				break;
			case CmdParameters.PARAM_NAME_TASK_STARTTIME:
				paramValue = resolveTime(getStartTime(fullParam));
				break;
			case CmdParameters.PARAM_NAME_TASK_PRIORITY:
				paramValue = getPriority(fullParam);
				break;
			case CmdParameters.PARAM_NAME_MARK_FLAG:
				paramValue = getMarkOption(fullParam);
				break;
			case CmdParameters.PARAM_NAME_LIST_FLAG:
				paramValue = getListOption(fullParam);
				break;
		}

		return paramValue;
	}

	/**
	 * Resolves a user formatted date to a date in system time
	 * 
	 * @param timeS
	 *            The user date to resolve
	 * @return The system time in string
	 */
	private String resolveTime(String timeS) {
		if (timeS == null) {
			return null;
		}
		
		long time = timeP.resolveTime(timeS); // Resolve the time
		if (time == TimeProcessor.TIME_INVALIDFORMAT) { // Unable to resolve time
			return FIELD_INVALID;
		}
		return Long.toString(time); // Convert the time to String
	}

	/**
	 * Returns the list of flags supported for a field
	 * 
	 * @param field
	 *            The field to find
	 * @return The list of flags for that field
	 */
	private String[] getFlagForField(String field) {

		switch (field) {
			case CmdParameters.PARAM_NAME_TASK_SNAME:
				return new String[] { ParserConstants.TASK_SPECIFIER_TASKNAME };
			case CmdParameters.PARAM_NAME_TASK_ENDTIME:
				return new String[] { ParserConstants.TASK_SPECIFIER_ENDTIME };
			case CmdParameters.PARAM_NAME_TASK_STARTTIME:
				return new String[] { ParserConstants.TASK_SPECIFIER_STARTTIME };
			case CmdParameters.PARAM_NAME_TASK_PRIORITY:
				return new String[] { ParserConstants.TASK_SPECIFIER_PRIORITY };
			case CmdParameters.PARAM_NAME_LIST_FLAG:
				return new String[] { ParserConstants.TASK_FILTER_ALL, ParserConstants.TASK_FILTER_DONE };
			case CmdParameters.PARAM_NAME_MARK_FLAG:
				return new String[] { ParserConstants.TASK_MARK_UNMARK };
		}

		return null;
	}

	/**
	 * Checks whether the flags entered by the user is valid
	 * 
	 * @param fields
	 *            The fields of the command
	 * @param userCmd
	 *            The user input to check
	 * @return True if the flags are valid, false otherwise
	 */
	private boolean hasValidFlags(String[] fields, String userCmd) {
		String[] userFlags = StringUtil.getOccurrences(userCmd, "(-\\S+)\\s?"); // Get all the flags
		
		// Return true since no user flag is specified
		if(userFlags == null || userFlags.length == 0){
			return true;
		}
		
		HashSet<String> cmdFlags = new HashSet<>();

		// Compile the list of supported flags for that command
		for (String aField : fields) {
			cmdFlags.addAll(Arrays.asList(getFlagForField(aField)));
		}

		// Check whether the flag entered by user is supported by that command
		for (String aFlag : userFlags) {
			if (!cmdFlags.contains(aFlag)) { // An unsupported flag is found
				return false;
			}
		}

		return true;
	}

}
```
###### parser\ParserConstants.java
``` java
/**
 * Keeps a list of user input constants to be resolved by both LanguageProcessor and Command
 *
 * @author amoshydra
 */
package parser;

public class ParserConstants {
		public static final String DELIMITER_TOKEN = "-";

		public static final String TASK_SPECIFIER_TASKNAME = DELIMITER_TOKEN + "name";
		public static final String TASK_SPECIFIER_STARTTIME = DELIMITER_TOKEN + "sd";
		public static final String TASK_SPECIFIER_ENDTIME = DELIMITER_TOKEN + "ed";
		public static final String TASK_SPECIFIER_PRIORITY = DELIMITER_TOKEN + "p";

		public static final String TASK_FILTER_ALL = DELIMITER_TOKEN + "all";
		public static final String TASK_FILTER_DONE = DELIMITER_TOKEN + "done";
		public static final String TASK_FILTER_FLOATING = DELIMITER_TOKEN + "floating";

		public static final String TASK_SETTING_NEWFILE = DELIMITER_TOKEN + "nf";
		public static final String TASK_SETTING_OPENFILE = DELIMITER_TOKEN + "of";
		
		public static final String TASK_MARK_UNMARK = DELIMITER_TOKEN + "um";
		
		public static final String[] TASK_PRIORITY_HIGH = {"high","h"};
		public static final String[] TASK_PRIORITY_NORM = {"norm","normal","n"};
		public static final String[] TASK_PRIORITY_LOW = {"low","l"};
}
```
###### parser\TimeProcessor.java
``` java
/**
 * Resolves time from user input
 * 
 * Examples of supported date formats (after removing white spaces, comma, and slash :
 * Time for today: 4pm / 2359 (24 hour format)
 * Next specified day with time: Wed <time> / Wednesday <time>
 * Date with month and time: 24 Jul <time> / Jul 24 <time> / 2407 <time> 
 * Date with month, year and time: 24 Jul 15 <time> / 240715 <time>
 * 
 */
package parser;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;

import util.TimeUtil;

/**
 * @author Yan Chan Min Oo
 *
 */
public class TimeProcessor {

	/*
	 * Constants
	 */
	// Return values upon resolving time input
	public static final long TIME_NOTSPECIFIED = 0;
	public static final long TIME_INVALIDFORMAT = -1;

	// Supported date formats for user input, and their maximum allowable
	// characters for parsing with that pattern
	private static final String[][] PATTERN_IN_TIME = { { "hha", "4" }, { "HHmm", "4" } };
	private static final String[][] PATTERN_IN_DAY = { { "Ehha", "7" }, { "EHHmm", "7" } };
	private static final String[][] PATTERN_IN_MONTHDAY = { { "ddMMMhha", "9" }, { "ddMMMHHmm", "9" },
			{ "MMMddhha", "9" }, { "MMMddHHmm", "9" }, { "ddMMhha", "8" }, { "ddMMHHmm", "8" } };
	private static final String[][] PATTERN_IN_DATE = { { "ddMMMyyhha", "11" }, { "ddMMMyyHHmm", "11" },
			{ "ddMMyyhha", "10" }, { "ddMMyyHHmm", "10" } };
	// Indexes for the above date formats
	private static final int INDEX_PATTERN = 0;
	private static final int INDEX_MAXCHAR = 1;

	// Supported date formats for output
	private static final String PATTERN_OUT_TIME = "HH:mm";
	private static final String PATTERN_OUT_DAYTIME = "E HH:mm";
	private static final String PATTERN_OUT_DATETIME = "dd MMM HH:mm";

	// Messages for relative dates
	private static final String FORMAT_TMR = "Tmr %1$s";
	private static final String FORMAT_TODAY = "Today %1$s";
	private static final String FORMAT_YTD = "Ytd %1$s";
	private static final String FORMAT_NEXTWEEK = "Next %1$s";
	private static final String FORMAT_ENDDATE = "By %1$s %2$s";
	private static final String FORMAT_DUEIN = "(In %1$s day(s))";
	private static final String FORMAT_OVERDUE = "(%1$s day(s) ago)";
	private static final String FORMAT_STARTENDDATE = "%1$s to %2$s";
	/*
	 * Variables
	 */
	private static TimeProcessor timeP; // Keep a copy of itself
	private Calendar now; // Keeps the current time
	private Calendar temp; // To be used for computing dates from input/output
	private static SimpleDateFormat sdf;

	private TimeProcessor() {
		sdf = new SimpleDateFormat();
		sdf.setTimeZone(TimeZone.getDefault());
		sdf.setLenient(false);
		now = Calendar.getInstance(TimeZone.getDefault());
		temp = Calendar.getInstance(TimeZone.getDefault());
	}

	/**
	 * Converts a user date into a system time
	 * 
	 * @param time
	 *            The time to convert
	 * @return The system time in long after parsing the user's system time. 0
	 *         if the time is not specified, -1 if the time cannot be parsed due
	 *         to invalid format
	 */
	public long resolveTime(String time) {

		// Allow users to reset/remove time
		if (time.equals(Long.toString(TIME_NOTSPECIFIED))) {
			return TIME_NOTSPECIFIED;
		}

		time = reformatDate(time); // Convert the user's time to a format which we can process easily

		long parsedTime = TIME_INVALIDFORMAT;

		// Try to parse with each date format
		for (int i = 1; i <= 4; i++) {
			switch (i) {
			case 1:
				parsedTime = parseFullDate(time);
				break;
			case 2:
				parsedTime = parseMonthDate(time);
				break;
			case 3:
				parsedTime = parseDay(time);
				break;
			case 4:
				parsedTime = parseTime(time);
				break;
			}

			// Check if the date have been successfully parsed
			if (parsedTime != TIME_INVALIDFORMAT) {
				return parsedTime;
			}
		}

		return TIME_INVALIDFORMAT; // Unable to parse date
	}

	/**
	 * Pads a date with zeros in fields when necessary, and removes white
	 * spaces, commas, slash, and colon, and dot
	 * 
	 * @param date
	 *            The date to convert
	 * @return The converted date
	 */
	private String reformatDate(String date) {
		String dateDelimit = "\\s|,|/|:|\\."; // Tokens to delimit fields and remove
		String fields[] = date.split(dateDelimit); // The fields to pad zeros with if necessary
		StringBuilder newField = new StringBuilder(); // The result

		for (String aField : fields) {

			// Left pad a zero in cases where single/odd digits are found
			if ((aField.length() == 1 && aField.matches("\\d")) || (aField.length() == 3 && aField.matches("\\d{3}"))
					|| (aField.length() == 4 && aField.matches("\\d[a-zA-Z]{3}"))) {
				aField = "0" + aField;
			}

			newField.append(aField);
		}
		return newField.toString();
	}

	/**
	 * Parses a date containing <Day of month><Month><Year><Time>
	 * 
	 * @param time
	 *            The time to parse
	 * @return System time in long if date is parsed, -1 if it isn't
	 */
	private long parseFullDate(String time) {

		// Try to parse with each pattern
		for (String[] pattern : PATTERN_IN_DATE) {
			
			// # of char at input must be lesser than the allowed # of char for that pattern
			if (time.length() > Integer.parseInt(pattern[INDEX_MAXCHAR])){
				continue;
			}
			
			sdf.applyPattern(pattern[INDEX_PATTERN]);

			try {
				temp.setTime(sdf.parse(time)); // Convert directly

				return temp.getTimeInMillis();
			} catch (ParseException e) { // Not this format
			} 
			
		}
		
		return TIME_INVALIDFORMAT;
	}

	/**
	 * Parse a date containing <Day of month><Month><Time> or <Month in
	 * text><Day of month><Time>
	 * 
	 * @param time
	 *            The time to parse
	 * @return System time in long if date is parsed, -1 if it isn't
	 */
	private long parseMonthDate(String time) {

		// Try to parse with each pattern
		for (String[] pattern : PATTERN_IN_MONTHDAY) {
			
			// # of char at input must be lesser than the allowed # of char for that pattern
			if (time.length() > Integer.parseInt(pattern[INDEX_MAXCHAR])){
				continue;
			}

			sdf.applyPattern(pattern[INDEX_PATTERN]);

			try {
				temp.setTime(sdf.parse(time));
				temp.set(Calendar.YEAR, now.get(Calendar.YEAR)); // Set the year since it's not specified in the input

				return temp.getTimeInMillis();
			} catch (ParseException e) { // Not this format
			} 
			
		}

		return TIME_INVALIDFORMAT;
	}

	/**
	 * Parse a date containing <Day of week><Time>. The date returned will be on
	 * the following specified day after the current day. Eg, if Wed 2200 is
	 * entered on a Wed, the next coming Wed will be returned.
	 * 
	 * @param time
	 *            The time to parse
	 * @return System time in long of the following specified day if date is
	 *         parsed, -1 if it isn't
	 */
	private long parseDay(String time) {

		// Try to parse with each pattern
		for (String[] pattern : PATTERN_IN_DAY) {

			// # of char at input must be lesser than the allowed # of char for that pattern
			if (time.length() > Integer.parseInt(pattern[INDEX_MAXCHAR])) {
				continue;
			}
				
			sdf.applyPattern(pattern[INDEX_PATTERN]);

			try {
				// Extract the day of week and time
				temp.setTime(sdf.parse(time));
				int day = temp.get(Calendar.DAY_OF_WEEK);
				int hour = temp.get(Calendar.HOUR_OF_DAY);
				int min = temp.get(Calendar.MINUTE);

				temp.setTimeInMillis(System.currentTimeMillis()); // Get the current time

				// Fast forward to the day specified
				do {
					temp.add(Calendar.DAY_OF_YEAR, 1);
				} while (temp.get(Calendar.DAY_OF_WEEK) != day);

				// Set the time
				temp.set(Calendar.HOUR_OF_DAY, hour);
				temp.set(Calendar.MINUTE, min);
				temp.set(Calendar.SECOND, 0);
				temp.set(Calendar.MILLISECOND, 0);

				return temp.getTimeInMillis();
			} catch (ParseException e) { // Not this format
			}
			
		}

		return TIME_INVALIDFORMAT;
	}

	/**
	 * Parse a date containing <Time>. The date returned will be on the same day
	 * if the time specified is after the current time, or on the next day if it
	 * is before the current time.
	 * 
	 * @param time
	 *            The time to parse
	 * @return System time in long if date is parsed, -1 if it isn't
	 */
	@SuppressWarnings("deprecation")
	private long parseTime(String time) {

		// Try to parse with each pattern
		for (String[] pattern : PATTERN_IN_TIME) {
			
			// # of char at input must be lesser than the allowed # of char for that pattern
			if (time.length() > Integer.parseInt(pattern[INDEX_MAXCHAR])) {
				continue;
			}

			sdf.applyPattern(pattern[INDEX_PATTERN]);

			try {
				Date dtime = sdf.parse(time);

				temp.setTimeInMillis(System.currentTimeMillis()); // Get the current time

				// Set the specified time of the day
				temp.set(Calendar.HOUR_OF_DAY, dtime.getHours());
				temp.set(Calendar.MINUTE, dtime.getMinutes());
				temp.set(Calendar.SECOND, 0);
				temp.set(Calendar.MILLISECOND, 0);

				// Fast forward to the next day if the date is before the current time
				if (TimeUtil.isBeforeNow(temp.getTimeInMillis())) {
						temp.add(Calendar.DAY_OF_YEAR, 1);
				}
					
				return temp.getTimeInMillis();
			} catch (ParseException e) {// Not this format
			} 
			
		}

		return TIME_INVALIDFORMAT;
	}

	/**
	 * Converts a date in system time to a formatted date
	 * 
	 * @param endTime
	 *            The end time to convert
	 * @return The formatted date
	 */
	public String getFormattedDate(long endTime) {

		int daysDiff = TimeUtil.getDayDifference(endTime);
		String extraMsg;

		if (daysDiff < 0) { // Overdue
			extraMsg = String.format(FORMAT_OVERDUE, -daysDiff);
		} else if (daysDiff == 0) { // Same day
			extraMsg = "";
		} else { // Due in the future
			extraMsg = String.format(FORMAT_DUEIN, daysDiff);
		}

		return String.format(FORMAT_ENDDATE, getRelativeDate(endTime), extraMsg);
	}

	/**
	 * Converts the start and end date in system time to a formatted date
	 * 
	 * @param startTime
	 *            The start time to convert
	 * @param endTime
	 *            The end time to convert
	 * @return The formatted date
	 */
	public String getFormattedDate(long startTime, long endTime) {
		return String.format(FORMAT_STARTENDDATE, getRelativeDate(startTime), getRelativeDate(endTime));
	}

	/**
	 * Converts a date in system time to its relative date from the current time
	 * 
	 * @param time
	 *            The time to convert
	 * @return The formatted date
	 */
	private String getRelativeDate(long time) {
		temp.setTimeInMillis(time);
		int dayDifference = TimeUtil.getDayDifference(time); // Get the day
																// difference
		sdf.applyPattern(PATTERN_OUT_TIME); // Use the pattern suitable for
											// displaying dates within 1 day
											// away

		// Check if the date is within 1 day away
		if (dayDifference == 0) { // Same day
			return String.format(FORMAT_TODAY, sdf.format(temp.getTime()));
		} else if (dayDifference == 1) { // Next day
			return String.format(FORMAT_TMR, sdf.format(temp.getTime()));
		} else if (dayDifference == -1) {// Yesterday
			return String.format(FORMAT_YTD, sdf.format(temp.getTime()));
		}

		int weekDifference = TimeUtil.getWeekDifference(time);// Get the week
																// difference
		sdf.applyPattern(PATTERN_OUT_DAYTIME); // Use the pattern suitable for
												// displaying dates within 1
												// week away

		// Check if the date is within this week or next week
		if (weekDifference == 0) { // This week
			return sdf.format(temp.getTime());
		} else if (weekDifference == 1) { // Next week
			return String.format(FORMAT_NEXTWEEK, sdf.format(temp.getTime()));
		}

		sdf.applyPattern(PATTERN_OUT_DATETIME); // Use the default pattern to
												// display dates

		return sdf.format(temp.getTime());
	}

	/**
	 * Returns an instance of itself. Allows only 1 instance of this class
	 * 
	 * @return The current instance
	 */
	public static TimeProcessor getInstance() {
		if (timeP == null) {
			timeP = new TimeProcessor();
		}
		return timeP;
	}

}
```
###### test\ParserTest.java
``` java
package test;

import parser.CommandProcessor;
import parser.TimeProcessor;
import static org.junit.Assert.*;

import logic.command.*;

import org.junit.Test;

/**
 * @author Yan Chan Min Oo
 *
 */
public class ParserTest {
	/*
	 * Constants
	 */
	private static final String CMD_FILENAME = "commands.xml";
	/*
	 * Variables
	 */
	TimeProcessor tp;
	CommandProcessor cp;

	private String[] _timeStringArray = {
			"",
			"0", // Zero/Date removal test
			"24 Jul 10 pm",
			"10 Jul 11 Pm",
			"10 Jul 2300",
			"Jul 10, 11 pm",
			"Jul 10 2300",
			"10 07 11pm",
			"10 07 2300", // 10 Jul 2300
			"07 10 11pm", // 7 Oct 11pm
			"07 10 2300", // 7 Oct 11pm
			"08/12/16 1pm",
			"7 10 16 720", // Padding test
			"07 10 16", // No time test
			"07 10 16 2400" // Time range test
			};

	private Long[] _timeLongArray = {
			-1L,
			0L,
			1437746400000L,
			1436540400000L,
			1436540400000L,
			1436540400000L,
			1436540400000L,
			1436540400000L,
			1436540400000L,
			1444230000000L,
			1444230000000L,
			1481173200000L,
			1475796000000L,
			-1L,
			-1L
		};

	@Test
	public void testTime(){
		tp = TimeProcessor.getInstance();
		int numOfElement = _timeStringArray.length;

		for (int index = 0; index < numOfElement; index++) {
			String timeString = _timeStringArray[index];
			Long timeLong = _timeLongArray[index];

			Long result = tp.resolveTime(timeString);
			
			assertEquals(result, timeLong);
		}
	}

	@Test
	public void testCmd(){
		cp = CommandProcessor.getInstance();

		cp.initCmdList(CMD_FILENAME);
		assertTrue(cp.getCmdType("add") instanceof CmdAdd);
		assertEquals(cp.getCmdType("@"),null);
		assertTrue(cp.getCmdType("+") instanceof CmdAdd);
		assertTrue(cp.getCmdType("mark") instanceof CmdMark);
	}

	@Test
	public void test(){
		testTime();
		testCmd();
	}

}
```
###### ui\UIHelper.java
``` java
/**
 * Provides methods for classes to interact with UIController
 *
 * @author Yan Chan Min Oo
 */
package ui;

import java.util.List;
import taskCollections.Task;

public class UIHelper {

	private static UIController uiController;

	/**
	 * Returns a string of the user input. Triggered on enter press.
	 */

	public static String getUserInput() {
		return uiController.getInput();
	}

	public static void createUI() {
		UIController.createUI();
		uiController = UI.getController();
	}

	// give the entire list for output generation
	public static void setTableOutput(List<Task> completeList) {
		uiController.generateTablesOutput(completeList);
	}

	// set UI's output msg
```
###### util\StringUtil.java
``` java
/**
 * Provides methods which allows String manipulation
 * 
 * @author Yan Chan Min Oo
 *
 */

package util;

import java.util.LinkedList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StringUtil {

	private static final String WHITESPACE = " ";

	/**
	 * Takes in a string, and returns the first word, delimited by a whitespace
	 * @param input
	 * 			The input to extract the word from
	 * @return
	 * 			The word if found, null otherwise
	 */
	public static String getFirstWord(String input) {
		assert input != null;
		assert !input.isEmpty();
		String[] tokens = input.split(WHITESPACE);
		
		if(tokens.length < 1){
			return null;
		}
		return input.split(WHITESPACE)[0];
	}

	/**
	 * Takes in a string, removes the first word and returns the rest
	 * @param input
	 * 			The input to remove the word from
	 * @return
	 * 			The remaining string after word is removed if word deletion is successful,
	 * 			null otherwise
	 */
	public static String removeFirstWord(String input) {
		String[] tokens = input.split(WHITESPACE, 2);
		if (tokens.length < 2) {
			return null;
		} else {
			return tokens[1];
		}
	}

	/**
	 * Takes in a search term (word), and look for it in a full string. Returns
	 * true if that word is found, false if it isn't
	 * @param searchIn
	 * 			The string to search in
	 * @param searchTerm
	 * 			The string to look for
	 * @return
	 * 			True if search term is found, false otherwise
	 */
	public static boolean containsWord(String searchIn, String searchTerm) {
		String regex = "\\b" + searchTerm + "\\b";

		Matcher m = Pattern.compile(regex).matcher(searchIn);

		return m.find();
	}

	/**
	 * Takes in a search term, look for it, then return the word following the
	 * search term
	 * 
	 * @param fullString
	 *            The full string to search in
	 * @param searchTerm
	 *            The search term
	 * @return The following word if searchTerm is found, null if it isn't
	 */
	public static String getWordAfter(String fullString, String searchTerm) {
		Matcher m = Pattern.compile("\\b" + Pattern.quote(searchTerm) + "\\b\\s\\b(.*){1}\\b").matcher(fullString);
		if (m.find()) {
			String tokens[] = m.group(1).split(WHITESPACE);
			return tokens[0];
		} else {
			return null;
		}
	}

	/**
	 * Takes in a search term, look for it, then return the entire string
	 * following the search term
	 * 
	 * @param fullString
	 *            The full string to search in
	 * @param searchTerm
	 *            The search term
	 * @return The following string if searchTerm is found, null if it isn't
	 */
	public static String getStringAfter(String fullString, String searchTerm) {
		Matcher m = Pattern.compile(Pattern.quote(searchTerm) + "(.*)").matcher(fullString);
		if (m.find()) {
			return m.group(1);
		} else {
			return null;
		}
	}

	/**
	 * Takes in a search term, look for it, then return the string following the
	 * search term, before stopAt
	 * 
	 * @param fullString
	 *            The full string to search in
	 * @param searchTerm
	 *            The search term NOTE: Support for multiple search terms using
	 *            | is not supported yet
	 * @param stopAt
	 *            The term to stop the string search at its first regex match, if
	 *            it is found
	 * @return The following string if searchTerm is found, null if it isn't
	 */
	public static String getStringAfter(String fullString, String searchTerm, String stopAt) {
		String [] tokens = fullString.split(" ");
		StringBuilder result = new StringBuilder();
		int i = 0;
		if(searchTerm != null && !searchTerm.isEmpty()){
			for(; i < tokens.length;i++){
				if(tokens[i].equals(searchTerm)){
					break;
				}
			}
			i++;
		}
	
		for(; i < tokens.length;i++){
			if(tokens[i].matches(stopAt)){
				break;
			} else {
				result.append(tokens[i] + " ");
			}
		}
		return result.length() == 0 ? null : result.toString();
	}
	
	/**
	 * Removes leading and trailing white spaces
	 * @param s
	 * 		The string to trim
	 * @return
	 * 		The trimmed string
	 */
	public static String trim(String s){
		if(s != null){
			return s.trim();
		} else {
			return null;
		}
	}
	
	/**
	 * Gets all occurrences of regex matches on a string
	 * @param fullString
	 * 			The string to analyse
	 * @param regex
	 * 			The regex to use
	 * @return
	 * 			A list of occurrences found. Null if no results are found
	 */
	public static String[] getOccurrences(String fullString, String regex){
		LinkedList<String> result = new LinkedList<>();
		Matcher m = Pattern.compile(regex).matcher(fullString);
		
		while(m.find()){
			result.add(m.group().trim());
		}
		
		return result.isEmpty() ? null : result.toArray(new String[result.size()]);
	}

}
```
###### util\TimeUtil.java
``` java
/**
 * Provides a list of methods to manipulate time for classes to use
 * 
 * @author Yan Chan Min Oo
 */
package util;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.concurrent.TimeUnit;

public class TimeUtil {

	private static SimpleDateFormat _df1 = new SimpleDateFormat("EEEE: dd/MM/yy HH:mm 'GMT'Z");
	private static SimpleDateFormat _uidf = new SimpleDateFormat("EEEE, dd MMM yy");
	private static Calendar now = Calendar.getInstance();
	private static Calendar temp = Calendar.getInstance();

	/**
	 * Converts a system time in string to long format.
	 * 
	 * @return System time in long format if the string is valid
	 */
	public static long sysStringToLongTime(String sysTimeInString) {
		try {
			return Long.parseLong(sysTimeInString);
		} catch (NumberFormatException e) {
			return 0;
		}
	}
	
	public static int getWeekDifference(long time) {
		now.setTimeInMillis(System.currentTimeMillis());
		temp.setTimeInMillis(time);
		return temp.get(Calendar.WEEK_OF_YEAR) - now.get(Calendar.WEEK_OF_YEAR);
	}

	public static int getDayDifference(long time) {
		now.setTimeInMillis(System.currentTimeMillis());
		temp.setTimeInMillis(time);
		if(now.get(Calendar.YEAR) == temp.get(Calendar.YEAR)){
			return temp.get(Calendar.DAY_OF_YEAR) - now.get(Calendar.DAY_OF_YEAR);
		}
		boolean isBefore = isBeforeNow(temp.getTimeInMillis());
		long diff = isBefore ? now.getTimeInMillis() - temp.getTimeInMillis() : 
			temp.getTimeInMillis() - now.getTimeInMillis();
		long daysDiff = TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
		if(isBefore){
			daysDiff = -daysDiff;
		}
		
		return (int)daysDiff;
	}
	
	public static boolean isBeforeNow(long time){
		now.setTimeInMillis(System.currentTimeMillis());
		temp.setTimeInMillis(time);
		return temp.getTime().before(now.getTime());
	}
	
	public static int compareMinTime(long t1, long t2){
		temp.setTimeInMillis(t1);
		temp.set(Calendar.SECOND, 0);
		temp.set(Calendar.MILLISECOND, 0);
		t1 = temp.getTimeInMillis();
		
		temp.setTimeInMillis(t2);
		temp.set(Calendar.SECOND, 0);
		temp.set(Calendar.MILLISECOND, 0);
		t2 = temp.getTimeInMillis();
		
		return Long.compare(t1, t2);
	}

```
